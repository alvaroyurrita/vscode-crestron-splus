import {
    DocumentSelector,
    ExtensionContext,
    TextDocument,
    window,
    workspace,
    TextDocumentChangeEvent,
    Position,
    Range,
    CompletionItemKind,
    Disposable,
    Uri
} from "vscode";
import TextmateLanguageService, { TextmateToken } from "vscode-textmate-languageservice";
import { SimplObject } from "./simplObject";
export class DocumentTokenService implements Disposable {
    private _documents = new Map<string, SimplObject>();
    private static _instance: DocumentTokenService;
    private selector: DocumentSelector = 'simpl-plus';
    private _textmateService: TextmateLanguageService;
    public static getInstance(ctx: ExtensionContext): DocumentTokenService {
        if (!DocumentTokenService._instance && ctx) {
            DocumentTokenService._instance = new DocumentTokenService(ctx);
        }
        return DocumentTokenService._instance;
    }
    public dispose() {
        this._documents.clear();
    }
    public getTokens(uri: Uri): SimplObject | undefined {
        const token = this._documents.get(uri.toString());
        if (token === undefined) {return undefined;}
        return this._documents.get(uri.toString());
    }
    private constructor(ctx: ExtensionContext) {
        this._textmateService = new TextmateLanguageService(this.selector.toString(), ctx);
        const onOpenTextDocument_event = workspace.onDidOpenTextDocument((document) => this.updateOnOpenTextDocument(document));
        const onDidChangeTextDocument_event = workspace.onDidChangeTextDocument((editor) => this.updateOnDidChangeTextDocument(editor));
        const onCloseTextDocument_event = workspace.onDidCloseTextDocument((document) => this.updateOnCloseTextDocument(document));

        const document = window.activeTextEditor?.document;
        if (document !== undefined && document.languageId === this.selector.toString()) { this.tokenize(document); }

        ctx.subscriptions.push(
            onOpenTextDocument_event,
            onDidChangeTextDocument_event,
            onCloseTextDocument_event,
        );
    }
    private async updateOnCloseTextDocument(document: TextDocument): Promise<void> {
        console.log("Document closed", document.fileName);
        if (document.languageId !== this.selector.toString()) { return; }
        this._documents.delete(document.uri.toString());
    }
    private async updateOnDidChangeTextDocument(editor: TextDocumentChangeEvent | undefined): Promise<void> {
        if (editor === undefined) { return; }
        const document = editor.document;
        if (document.languageId !== this.selector.toString()) { return; }
        await this.tokenize(document);
        const currentPosition = window.activeTextEditor?.selection.active;
        // console.log(currentPosition);
    }
    private async updateOnOpenTextDocument(document: TextDocument): Promise<void> {
        console.log("Document Open", document.fileName);
        if (document.languageId !== this.selector.toString()) { return; }
        await this.tokenize(document);
    }
    private async tokenize(document: TextDocument | undefined): Promise<void> {
        if (document === undefined) { return; }
        if (document.languageId !== this.selector.toString()) { return; }
        const textmateTokenService = await this._textmateService.initTokenService();
        const tokens = await textmateTokenService.fetch(document);

        const theDocument: SimplObject =
        {
            name: document.fileName.slice(document.fileName.lastIndexOf("\\") + 1, document.fileName.lastIndexOf(".")),
            kind: CompletionItemKind.Class,
            nameRange: new Range(new Position(0, 0), new Position(0, 0)),
            blockRange: new Range(new Position(0, 0), new Position(document.lineCount, 0)),
            dataType: "class",
            internalStructures: this.getGlobalStructures(tokens),
            internalConstants: this.getGlobalConstants(tokens),
            internalVariables: this.getGlobalVariables(tokens),
            internalFunctions: this.getGlobalFunctions(tokens),
            internalEvents: this.getGlobalEvents(tokens),
            uri: document.uri.toString(),
        };

        this._documents.set(document.uri.toString(), theDocument);
    }
    private getGlobalVariables(tokens: TextmateToken[]): SimplObject[] {
        return tokens.filter(token => token.scopes.includes("entity.name.variable.usp")
            && !(token.scopes.includes("meta.block.structure.usp")
                || token.scopes.includes("meta.block.usp"))).map(token => {
                    const variableType = this.getType(token, tokens);
                    const variableNameRange = new Range(
                        new Position(token.line, token.startIndex),
                        new Position(token.line, token.startIndex + token.text.length)
                    );
                    const variable: SimplObject = {
                        name: token.text,
                        kind: CompletionItemKind.Variable,
                        nameRange: variableNameRange,
                        dataType: variableType,
                    };
                    return variable;
                });
    }
    private getGlobalConstants(tokens: TextmateToken[]): SimplObject[] {
        return tokens.filter(token => token.scopes.includes("entity.name.constant.usp")).map(token => {
            const constantNameRange = new Range(
                new Position(token.line, token.startIndex),
                new Position(token.line, token.startIndex + token.text.length)
            );
            const constantIndex = tokens.indexOf(token);
            let dataType = "";
            if (constantIndex + 2 < tokens.length) {
                const constantValueToken = tokens[constantIndex + 2];
                switch (constantValueToken.type) {
                    case "constant.numeric.decimal.usp":
                    case "constant.numeric.hex.usp":
                    case "constant.numeric.character.usp":
                        dataType = "integer";
                        break;
                    case "string.quoted.double.usp":
                        dataType = "string";
                    default:
                        break;
                }
            }
            const constant: SimplObject = {
                name: token.text,
                kind: CompletionItemKind.Constant,
                nameRange: constantNameRange,
                dataType
            };
            return constant;
        });
    }
    private getGlobalFunctions(tokens: TextmateToken[]): SimplObject[] {
        return tokens.filter(token => token.scopes.includes("entity.name.function.usp")).map(token => {
            const functionType = this.getType(token, tokens);
            const functionNameRange = new Range(
                new Position(token.line, token.startIndex),
                new Position(token.line, token.startIndex + token.text.length)
            );
            //look for function block statement range
            const functionTokens = this.getBlockRangeTokens(tokens, token, "meta.block.usp");
            let functionBlockRange: Range;
            let functionVariables: SimplObject[] = [];
            if (functionTokens.length !== 0) {
                functionBlockRange = new Range(
                    new Position(functionTokens[0].line, functionTokens[0].startIndex),
                    new Position(functionTokens[functionTokens.length - 1].line,
                        functionTokens[functionTokens.length - 1].startIndex + functionTokens[functionTokens.length - 1].text.length)
                );
                //grab all variables from range
                functionVariables = functionTokens.
                    filter(token => token.scopes.includes("entity.name.variable.usp")).
                    map(token => {
                        const variableType = this.getType(token, tokens);
                        const variableNameRange = new Range(
                            new Position(token.line, token.startIndex),
                            new Position(token.line, token.startIndex + token.text.length)
                        );
                        const variable: SimplObject = {
                            name: token.text,
                            kind: CompletionItemKind.Variable,
                            nameRange: variableNameRange,
                            dataType: variableType,
                        };
                        return variable;
                    });
            }
            //grab all tokens inside the parenthesized parameter list
            const parameterTokens = this.getBlockRangeTokens(tokens, token, "meta.parenthesized.parameter-list.usp");
            let functionParameters: SimplObject[] = [];
            let parameterBlockRange: Range;
            if (parameterTokens.length !== 0) {
                parameterBlockRange = new Range(
                    new Position(parameterTokens[0].line, parameterTokens[0].startIndex),
                    new Position(parameterTokens[parameterTokens.length - 1].line,
                        parameterTokens[parameterTokens.length - 1].startIndex + parameterTokens[parameterTokens.length - 1].text.length)
                );
                //extract parameter variable names
                functionParameters = parameterTokens.
                    filter(token => token.scopes.includes("entity.name.variable.parameter.usp")).
                    map(token => {
                        const parameterType = this.getType(token, tokens);
                        const parameterNameRange = new Range(
                            new Position(token.line, token.startIndex),
                            new Position(token.line, token.startIndex + token.text.length)
                        );
                        const variable: SimplObject = {
                            name: token.text,
                            kind: CompletionItemKind.TypeParameter,
                            nameRange: parameterNameRange,
                            dataType: parameterType,
                        };
                        return variable;
                    });
            }
            const fun: SimplObject = {
                name: token.text,
                kind: CompletionItemKind.Function,
                nameRange: functionNameRange,
                dataType: functionType,
                parameters: functionParameters,
                blockRange: functionBlockRange,
                parameterRange: parameterBlockRange,
                internalVariables: functionVariables,
            };
            return fun;
        });
    }
    private getGlobalStructures(tokens: TextmateToken[]): SimplObject[] {
        return tokens.filter(token => token.scopes.includes("entity.name.type.structure.usp")).map(token => {
            const structureNameRange = new Range(
                new Position(token.line, token.startIndex),
                new Position(token.line, token.startIndex + token.text.length)
            );
            //look for structure block statement range
            const structureTokens = this.getBlockRangeTokens(tokens, token, "meta.block.structure.usp");
            const structureBlockRange = new Range(
                new Position(structureTokens[0].line, structureTokens[0].startIndex),
                new Position(structureTokens[structureTokens.length - 1].line, structureTokens[structureTokens.length - 1].startIndex + structureTokens[structureTokens.length - 1].text.length)
            );
            //grab all variables from range
            const structureVariables = structureTokens.
                filter(token => token.scopes.includes("entity.name.variable.usp")).
                map(token => {
                    const variableType = this.getType(token, tokens);
                    const variableNameRange = new Range(
                        new Position(token.line, token.startIndex),
                        new Position(token.line, token.startIndex + token.text.length)
                    );
                    const variable: SimplObject = {
                        name: token.text,
                        kind: CompletionItemKind.Variable,
                        nameRange: variableNameRange,
                        dataType: variableType,
                    };
                    return variable;
                });
            const struct: SimplObject = {
                name: token.text,
                kind: CompletionItemKind.Struct,
                nameRange: structureNameRange,
                dataType: token.text,
                blockRange: structureBlockRange,
                internalVariables: structureVariables,
            };
            return struct;
        });
    }
    private getGlobalEvents(tokens: TextmateToken[]): SimplObject[] {
        return tokens.filter(token => token.scopes.includes("entity.name.variable.event.usp")).map(token => {
            const eventType = this.getType(token, tokens);
            const eventNameRange = new Range(
                new Position(token.line, token.startIndex),
                new Position(token.line, token.startIndex + token.text.length)
            );
            //look for event block statement range
            const eventTokens = this.getBlockRangeTokens(tokens, token, "meta.block.usp");
            const eventBlockRange = new Range(
                new Position(eventTokens[0].line, eventTokens[0].startIndex),
                new Position(eventTokens[eventTokens.length - 1].line, eventTokens[eventTokens.length - 1].startIndex + eventTokens[eventTokens.length - 1].text.length)
            );
            //grab all variables from range
            const eventVariables = eventTokens.
                filter(token => token.scopes.includes("entity.name.variable.usp")).
                map(token => {
                    const variableType = this.getType(token, tokens);
                    const variableNameRange = new Range(
                        new Position(token.line, token.startIndex),
                        new Position(token.line, token.startIndex + token.text.length)
                    );
                    const variable: SimplObject = {
                        name: token.text,
                        kind: CompletionItemKind.Variable,
                        nameRange: variableNameRange,
                        dataType: variableType,
                    };
                    return variable;
                });
            const event: SimplObject = {
                name: token.text,
                kind: CompletionItemKind.Event,
                nameRange: eventNameRange,
                dataType: eventType,
                blockRange: eventBlockRange,
                internalVariables: eventVariables,
            };
            return event;
        });
    }
    private getType(token: TextmateToken, tokens: TextmateToken[]): string {
        let tokenIndex = tokens.indexOf(token);
        if (tokenIndex < 0) { return ""; }
        do {
            --tokenIndex;
        } while (tokenIndex >= 0 && !(tokens[tokenIndex].type.includes("keyword.type") || tokens[tokenIndex].type.includes("entity.name.type")));
        return tokens[tokenIndex].text;
    }
    private getBlockRangeTokens(tokens: TextmateToken[], token: TextmateToken, scopeName: string): TextmateToken[] {
        let functionTokenBegin = tokens.indexOf(token);
        do {
            if (tokens[functionTokenBegin].scopes.includes(scopeName)) { break; }
            ++functionTokenBegin;
        } while (functionTokenBegin < tokens.length);
        if (functionTokenBegin >= tokens.length) { return []; }
        let functionTokenEnd = functionTokenBegin;
        do {
            if (!tokens[functionTokenEnd].scopes.includes(scopeName)) { break; }
            ++functionTokenEnd;
        } while (functionTokenEnd < tokens.length);
        return tokens.slice(functionTokenBegin, functionTokenEnd);
    }
}