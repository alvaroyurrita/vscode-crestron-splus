{
  "scopeName": "source.splus",
  "fileTypes": [
    "usp",
    "usl"
  ],
  "name": "Crestron",
  "patterns": [
    {
      "include": "#comment"
    },
    {
      "include": "#preprocessor"
    },
    {
      "include": "#declaration"
    }
  ],
  "repository": {
    "comment": {
      "patterns": [
        {
          "include": "#comment-single-line"
        },
        {
          "include": "#comment-block"
        }
      ]
    },
    "comment-single-line": {
      "name": "comment.line.double-slash.usp",
      "begin": "(^\\s+)?(\\/\\/).*$",
      "while": "^(\\s*)(\\/\\/).*$",
      "captures": {
        "1": {
          "name": "punctuation.whitespace.comment.leading.usp"
        },
        "2": {
          "name": "punctuation.definition.comment.usp"
        }
      }
    },
    "comment-block": {
      "name": "comment.block.usp",
      "begin": "\\/\\*",
      "end": "\\*\\/",
      "captures": {
        "0": {
          "name": "punctuation.definition.comment.usp"
        }
      }
    },
    "preprocessor": {
      "patterns": [
        {
          "include": "#preprocessor-parameter-properties"
        },
        {
          "include": "#preprocessor-block-help"
        },
        {
          "include": "#preprocessor-single-line"
        }
      ]
    },
    "preprocessor-single-line": {
      "name": "meta.preprocessor.usp",
      "begin": "^\\s*(\\#)",
      "beginCaptures": {
        "1": {
          "name": "punctuation.separator.hash.usp"
        }
      },
      "end": "(?<=$)",
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "include": "#preprocessor-define-constant"
        },
        {
          "include": "#preprocessor-if-ifnot-defined"
        },
        {
          "include": "#preprocessor-endif"
        },
        {
          "include": "#preprocessor-category"
        },
        {
          "include": "#preprocessor-library"
        },
        {
          "include": "#preprocessor-include-path"
        },
        {
          "include": "#preprocessor-symbol-name"
        },
        {
          "include": "#preprocessor-hint"
        },
        {
          "include": "#preprocessor-help"
        },
        {
          "include": "#preprocessor-default-nonvolatile-volatile"
        },
        {
          "include": "#preprocessor-analog-digital-expand"
        },
        {
          "include": "#preprocessor-output-shift"
        },
        {
          "include": "#preprocessor-max-internal-buffer-size"
        },
        {
          "include": "#preprocessor-single"
        }
      ]
    },
    "preprocessor-define-constant": {
      "begin": "(?ix)\\G\n  \\b(define_constant)\\b\\s*  #Directive\n  \\b([_[:alpha:]][\\#\\$\\_[:alnum:]]*)\\b\\s* #Constant Name",
      "end": "(?=$)",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.defineconstant.usp"
        },
        "2": {
          "name": "entity.name.variable.preprocessor.symbol.usp"
        }
      },
      "patterns": [
        {
          "match": "(\\G0[xX])([[:xdigit:]]{1,4})",
          "captures": {
            "1": {
              "name": "constant.numeric.other.prefix.hex.usp"
            },
            "2": {
              "name": "constant.numeric.hex.usp"
            }
          }
        },
        {
          "match": "(\\G[0-9]+)",
          "name": "constant.numeric.decimal.usp"
        },
        {
          "match": "(\\G\\'.\\')",
          "name": "constant.character.usp"
        },
        {
          "match": "(\\G\\\".*?\\\")",
          "name": "string.quoted.double.usp"
        }
      ]
    },
    "preprocessor-if-ifnot-defined": {
      "begin": "(?ix)\\G\n  \\b(?:(if_defined)|(if_not_defined))\\b\\s* #Directive",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.ifdefined.usp"
        },
        "2": {
          "name": "keyword.preprocessor.ifnotdefined.usp"
        }
      },
      "end": "(?=$)",
      "patterns": [
        {
          "match": "\\G([_[:alpha:]][\\#\\$\\_[:alnum:]]*)",
          "name": "entity.name.variable.preprocessor.symbol.usp"
        }
      ]
    },
    "preprocessor-endif": {
      "match": "(?ix)\\G\n  \\b(endif)\\b #Directive",
      "captures": {
        "1": {
          "name": "keyword.preprocessor.endif.usp"
        }
      }
    },
    "preprocessor-category": {
      "begin": "(?ix)\\G\n  \\b(category)\\b\\s* #Directive",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.category.usp"
        }
      },
      "end": "(?=$)",
      "patterns": [
        {
          "match": "\\G\\\"[0-9]*?\\\"",
          "name": "constant.numeric.category.usp"
        }
      ]
    },
    "preprocessor-library": {
      "begin": "(?ix)\\G\n  \\b((?:(?:user_simplsharp|crestron_simplsharp|user|crestron)_)library)\\b\\s*",
      "beginCaptures": {
        "1": {
          "patterns": [
            {
              "match": "(?i)((?:user_simplsharp).*)",
              "name": "keyword.preprocessor.usersimplsharplibrary.usp"
            },
            {
              "match": "(?i)((?:crestron_simplsharp).*)",
              "name": "keyword.preprocessor.crestronsimplsharplibrary.usp"
            },
            {
              "match": "(?i)((?:user).*)",
              "name": "keyword.preprocessor.userlibrary.usp"
            },
            {
              "match": "(?i)((?:crestron).*)",
              "name": "keyword.preprocessor.crestronlibrary.usp"
            }
          ]
        }
      },
      "end": "(?=$)",
      "patterns": [
        {
          "match": "\\G(\\\".*?\\\")",
          "name": "string.quoted.double.usp"
        }
      ]
    },
    "preprocessor-include-path": {
      "begin": "(?ix)\\G\n  \\b(includepath)\\b\\s* #Directive",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.includepath.usp"
        }
      },
      "end": "(?=$)",
      "patterns": [
        {
          "match": "\\G(\\\".*?\\\")",
          "name": "string.quoted.double.usp"
        }
      ]
    },
    "preprocessor-symbol-name": {
      "begin": "(?ix)\\G\n  \\b(symbol_name)\\b\\s* #Directive",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.symbolname.usp"
        }
      },
      "end": "(?=$)",
      "patterns": [
        {
          "match": "\\G(\\\".*?\\\")",
          "name": "string.quoted.double.usp"
        }
      ]
    },
    "preprocessor-hint": {
      "begin": "(?ix)\\G\n  \\b(hint)\\b\\s* #Directive",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.hint.usp"
        }
      },
      "end": "(?=$)",
      "patterns": [
        {
          "match": "\\G(\\\".*?\\\")",
          "name": "string.quoted.double.usp"
        }
      ]
    },
    "preprocessor-help": {
      "begin": "(?ix)\\G\n  \\b(help)\\b\\s* #Directive",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.help.usp"
        }
      },
      "end": "(?=$)",
      "patterns": [
        {
          "match": "\\G(\\\".*?\\\")",
          "name": "string.quoted.double.usp"
        }
      ]
    },
    "preprocessor-default-nonvolatile-volatile": {
      "match": "(?ix)\\G\n  \\b(default_nonvolatile)|(default_volatile)\\b #Directive",
      "captures": {
        "1": {
          "name": "keyword.preprocessor.defaultnonvolatile.usp"
        },
        "2": {
          "name": "keyword.preprocessor.defaultvolatile.usp"
        }
      }
    },
    "preprocessor-analog-digital-expand": {
      "begin": "(?ix)\\G\n  \\b(?:(analog_serial_expand)|(digital_expand))\\b\\s* #Directive",
      "end": "(?=$)",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.analogserialexpand.usp"
        },
        "2": {
          "name": "keyword.preprocessor.digitalexpand.usp"
        }
      },
      "patterns": [
        {
          "match": "(?ix)\\G\n  ([a-z]+)$",
          "name": "keyword.control.option.usp"
        }
      ]
    },
    "preprocessor-output-shift": {
      "begin": "(?ix)\\G\n  \\b(output_shift)\\b\\s* #Directive",
      "end": "(?=$)",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.outputshift.usp"
        }
      },
      "patterns": [
        {
          "match": "\\G[0-9]+",
          "name": "constant.numeric.decimal.usp"
        }
      ]
    },
    "preprocessor-max-internal-buffer-size": {
      "begin": "(?ix)\\G\n  \\b(max_internal_buffer_size)\\b\\s* #Directive",
      "end": "(?=$)",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.outputshift.usp"
        }
      },
      "patterns": [
        {
          "match": "\\G[0-9]+",
          "name": "constant.numeric.decimal.usp"
        }
      ]
    },
    "preprocessor-single": {
      "begin": "(?ix)\\G\n  (?:\\b\n    (?:\n      (print_to_trace)|\n      (enable_dynamic)|\n      (enable_stack_checking)|\n      (large_stack)|\n      (enable_trace)|\n      (encoding_ascii)|\n      (encoding_inherit_from_parent)|\n      (encoding_inherit_from_program)|\n      (encoding_utf16)|\n      (default_nonvolatile)|\n      (default_volatile)|\n      (endif)|\n      (if_series2)|\n      (if_series3)|\n      (if_series4)\n    )\\b)\n    \\s* #Directive",
      "end": "(?=$)",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.printtotrace.usp"
        },
        "2": {
          "name": "keyword.preprocessor.enabledynamic.usp"
        },
        "3": {
          "name": "keyword.preprocessor.enablestackchecking.usp"
        },
        "4": {
          "name": "keyword.preprocessor.largestack.usp"
        },
        "5": {
          "name": "keyword.preprocessor.enabletrace.usp"
        },
        "6": {
          "name": "keyword.preprocessor.encodingascii.usp"
        },
        "7": {
          "name": "keyword.preprocessor.encodinginheritfromparent.usp"
        },
        "8": {
          "name": "keyword.preprocessor.encodinginheritfromprogram.usp"
        },
        "9": {
          "name": "keyword.preprocessor.encodingutf16.usp"
        },
        "10": {
          "name": "keyword.preprocessor.defaultnonvolatile.usp"
        },
        "11": {
          "name": "keyword.preprocessor.defaultvolatile.usp"
        },
        "12": {
          "name": "keyword.preprocessor.endif.usp"
        },
        "13": {
          "name": "keyword.preprocessor.ifseries2.usp"
        },
        "14": {
          "name": "keyword.preprocessor.ifseries3.usp"
        },
        "15": {
          "name": "keyword.preprocessor.ifseries4.usp"
        }
      }
    },
    "preprocessor-parameter-properties": {
      "name": "meta.preprocessor.properties.usp",
      "begin": "(?ix)\n  (\\#)(begin_parameter_properties)\n  (\n    [\\_\\#\\_\\$\\,[:alnum:]\\s]*\n  )? #Parameter Properties Directive",
      "beginCaptures": {
        "0": {
          "name": "meta.preprocessor.usp"
        },
        "1": {
          "name": "punctuation.separator.hash.usp"
        },
        "2": {
          "name": "keyword.preprocessor.beginparameterproperties.usp"
        },
        "3": {
          "patterns": [
            {
              "match": "([\\_[:alpha:]][\\_\\#\\_\\$[:alnum:]]*)",
              "name": "entity.name.type"
            },
            {
              "include": "#punctuation-comma"
            }
          ]
        }
      },
      "end": "(?ix)\n  (\\#)(END_PARAMETER_PROPERTIES)",
      "endCaptures": {
        "0": {
          "name": "meta.preprocessor.usp"
        },
        "1": {
          "name": "punctuation.separator.hash.usp"
        },
        "2": {
          "name": "keyword.preprocessor.endparameterproperties.usp"
        }
      },
      "patterns": [
        {
          "include": "#preprocessor-parameter-properties-valid-unit"
        },
        {
          "include": "#preprocessor-parameter-properties-default-unit"
        },
        {
          "include": "#preprocessor-parameter-properties-default-value"
        },
        {
          "include": "#preprocessor-parameter-properties-list"
        },
        {
          "include": "#preprocessor-parameter-properties-bounds"
        },
        {
          "include": "#preprocessor-parameter-properties-short-description"
        },
        {
          "include": "#preprocessor-properties-block-description-notes"
        },
        {
          "include": "#comment"
        }
      ]
    },
    "preprocessor-parameter-properties-valid-unit": {
      "begin": "(?ix)\n  (\\#)\\b(propValidUnits)\\b #directive",
      "beginCaptures": {
        "0": {
          "name": "meta.preprocessor.usp"
        },
        "1": {
          "name": "punctuation.separator.hash.usp"
        },
        "2": {
          "name": "keyword.preprocessor.propvalidunits.usp"
        }
      },
      "end": "(;)",
      "endCaptures": {
        "1": {
          "name": "punctuation.terminator.parameteryproperty.usp"
        }
      },
      "patterns": [
        {
          "include": "#punctuation-assignment"
        },
        {
          "include": "#punctuation-pipe"
        },
        {
          "include": "#preprocessor-parameter-units"
        }
      ]
    },
    "preprocessor-parameter-properties-default-unit": {
      "begin": "(?ix)\n  (\\#)\\b(propDefaultUnits)\\b #directive",
      "beginCaptures": {
        "0": {
          "name": "meta.preprocessor.usp"
        },
        "1": {
          "name": "punctuation.separator.hash.usp"
        },
        "2": {
          "name": "keyword.preprocessor.propdefaultunits.usp"
        }
      },
      "end": "(;)",
      "endCaptures": {
        "1": {
          "name": "punctuation.terminator.parameteryproperty.usp"
        }
      },
      "patterns": [
        {
          "include": "#punctuation-assignment"
        },
        {
          "include": "#preprocessor-parameter-units"
        }
      ]
    },
    "preprocessor-parameter-properties-default-value": {
      "begin": "(?ix)\n  (\\#)\\b(propDefaultValue)\\b #directive",
      "beginCaptures": {
        "0": {
          "name": "meta.preprocessor.usp"
        },
        "1": {
          "name": "punctuation.separator.hash.usp"
        },
        "2": {
          "name": "keyword.preprocessor.propdefaultunits.usp"
        }
      },
      "end": "(;)",
      "endCaptures": {
        "1": {
          "name": "punctuation.terminator.parameteryproperty.usp"
        }
      },
      "patterns": [
        {
          "include": "#literals"
        }
      ]
    },
    "preprocessor-parameter-properties-list": {
      "begin": "(?ix)\n  (\\#)\\b(propList)\\b #directive",
      "beginCaptures": {
        "0": {
          "name": "meta.preprocessor.usp"
        },
        "1": {
          "name": "punctuation.separator.hash.usp"
        },
        "2": {
          "name": "keyword.preprocessor.proplist.usp"
        }
      },
      "end": "(;)",
      "endCaptures": {
        "1": {
          "name": "punctuation.terminator.parameteryproperty.usp"
        }
      },
      "patterns": [
        {
          "include": "#preprocessor-property-list-pair"
        },
        {
          "include": "#punctuation-comma"
        }
      ]
    },
    "preprocessor-parameter-properties-bounds": {
      "begin": "(?ix)\n  (\\#)\\b(propBounds)\\b #directive",
      "beginCaptures": {
        "0": {
          "name": "meta.preprocessor.usp"
        },
        "1": {
          "name": "punctuation.separator.hash.usp"
        },
        "2": {
          "name": "keyword.preprocessor.propBounds.usp"
        }
      },
      "end": "(;)",
      "endCaptures": {
        "1": {
          "name": "punctuation.terminator.parameteryproperty.usp"
        }
      },
      "patterns": [
        {
          "include": "#numeric-literal"
        },
        {
          "include": "#punctuation-comma"
        }
      ]
    },
    "preprocessor-parameter-properties-short-description": {
      "begin": "(?ix)\n  (\\#)\\b(propShortDescription)\\b #directive",
      "beginCaptures": {
        "0": {
          "name": "meta.preprocessor.usp"
        },
        "1": {
          "name": "punctuation.separator.hash.usp"
        },
        "2": {
          "name": "keyword.preprocessor.propShortDescription.usp"
        }
      },
      "end": "(;)",
      "endCaptures": {
        "1": {
          "name": "punctuation.terminator.parameteryproperty.usp"
        }
      },
      "patterns": [
        {
          "include": "#string-literal"
        }
      ]
    },
    "preprocessor-block-help": {
      "name": "meta.preprocessor.properties.help.usp",
      "contentName": "comment.block.documentation.usp",
      "begin": "(?i)(\\#)(help_begin)",
      "beginCaptures": {
        "1": {
          "name": "punctuation.separator.hash.usp"
        },
        "2": {
          "name": "keyword.preprocessor.helpbegin.usp"
        }
      },
      "end": "(?i)(\\#)(help_end)",
      "endCaptures": {
        "1": {
          "name": "punctuation.separator.hash.usp"
        },
        "2": {
          "name": "keyword.preprocessor.helpend.usp"
        }
      },
      "patterns": [
        {
          "include": "#comment"
        }
      ]
    },
    "preprocessor-properties-block-description-notes": {
      "name": "meta.preprocessor.properties.description.usp",
      "contentName": "comment.block.documentation.usp",
      "begin": "(?i)(\\#)(?:(begin_prop_full_description)|(begin_prop_notes))",
      "beginCaptures": {
        "0": {
          "name": "meta.preprocessor.usp"
        },
        "1": {
          "name": "punctuation.separator.hash.usp"
        },
        "2": {
          "name": "keyword.preprocessor.beginpropfulldescription.usp"
        },
        "3": {
          "name": "keyword.preprocessor.beginpropnotes.usp"
        }
      },
      "end": "(?i)(\\#)(?:(end_prop_full_description)|(end_prop_notes))$",
      "endCaptures": {
        "0": {
          "name": "meta.preprocessor.usp"
        },
        "1": {
          "name": "punctuation.separator.hash.usp"
        },
        "2": {
          "name": "keyword.preprocessor.endpropfulldescription.usp"
        },
        "3": {
          "name": "keyword.preprocessor.endpropnotes.usp"
        }
      }
    },
    "preprocessor-parameter-units": {
      "patterns": [
        {
          "match": "(?ix)\n  \\b(unitString|unitDecimal|unitHex|unitPercent|unitCharacter|unitTime|unitTicks)\\b #directive",
          "name": "keyword.preprocessor.$1."
        }
      ]
    },
    "preprocessor-property-list-pair": {
      "patterns": [
        {
          "match": "(\\{)([^}]*)(\\})",
          "captures": {
            "1": {
              "name": "punctuation.curlybrace.open.usp"
            },
            "2": {
              "patterns": [
                {
                  "match": "(.*)\\s?(,)\\s?(.*)",
                  "captures": {
                    "1": {
                      "patterns": [
                        {
                          "include": "#literals"
                        }
                      ]
                    },
                    "2": {
                      "name": "punctuation.comma.usp"
                    },
                    "3": {
                      "patterns": [
                        {
                          "include": "#string-literal"
                        }
                      ]
                    }
                  }
                }
              ]
            },
            "3": {
              "name": "punctuation.curlybrace.close.usp"
            }
          }
        }
      ]
    },
    "declaration": {
      "patterns": [
        {
          "include": "#input-declaration"
        },
        {
          "include": "#output-declaration"
        },
        {
          "include": "#parameter-declaration"
        },
        {
          "include": "#structure-declaration"
        },
        {
          "include": "#function-declaration"
        },
        {
          "include": "#event-declaration"
        },
        {
          "include": "#callback-declaration"
        },
        {
          "include": "#namespace-declaration"
        },
        {
          "include": "#variable-declaration"
        }
      ]
    },
    "input-declaration": {
      "name": "meta.declaration.input.usp",
      "begin": "(?ix)\n  (?=(?:digital_input|analog_input|buffer_input|string_input)) #start pattern at the beginning of the input keyword without grabbing any characters",
      "end": "(?ix)\n  (;)|(?=\\{)   #stop pattern before the closing curly brace or at semicolon",
      "endCaptures": {
        "1": {
          "name": "punctuation.terminator.input.usp"
        }
      },
      "patterns": [
        {
          "match": "(?i)\\b(digital_input|analog_input|buffer_input|string_input)\\b",
          "name": "keyword.declaration.input.usp"
        },
        {
          "match": "([\\_[:alpha:]][\\_\\#\\_\\$[:alnum:]]*)",
          "name": "entity.name.variable.input.usp"
        },
        {
          "include": "#declaration-skip"
        },
        {
          "include": "#comment"
        },
        {
          "include": "#punctuation-comma"
        },
        {
          "include": "#type-array-suffix"
        }
      ]
    },
    "output-declaration": {
      "name": "meta.declaration.output.usp",
      "begin": "(?ix)\n  (?=(?:digital_output|analog_output|buffer_output|string_output)) #start pattern at the beginning of the input keyword without grabbing any characters",
      "end": "(?ix)\n  (;)|(?=\\{)   #stop pattern before the closing curly brace or at semicolon",
      "endCaptures": {
        "1": {
          "name": "punctuation.terminator.output.usp"
        }
      },
      "patterns": [
        {
          "match": "(?i)\\b(digital_output|analog_output|buffer_output|string_output)\\b",
          "name": "keyword.declaration.output.usp"
        },
        {
          "match": "([\\_[:alpha:]][\\_\\#\\_\\$[:alnum:]]*)",
          "name": "entity.name.variable.output.usp"
        },
        {
          "include": "#declaration-skip"
        },
        {
          "include": "#comment"
        },
        {
          "include": "#punctuation-comma"
        },
        {
          "include": "#type-array-suffix"
        }
      ]
    },
    "parameter-declaration": {
      "name": "meta.declaration.parameter.usp",
      "begin": "(?ix)\n  (?=(?:integer_parameter|string_parameter|long_integer_parameter|signed_integer_parameter|signed_long_integer_parameter)) #start pattern at the beginning of the input keyword without grabbing any characters",
      "end": "(?ix)\n  (;)|(?=\\{)   #stop pattern before the closing curly brace or at semicolon",
      "endCaptures": {
        "1": {
          "name": "punctuation.terminator.parameter.usp"
        }
      },
      "patterns": [
        {
          "match": "(?i)\\b(integer_parameter|string_parameter|long_integer_parameter|signed_integer_parameter|signed_long_integer_parameter)\\b",
          "name": "keyword.declaration.parameter.usp"
        },
        {
          "match": "([\\_[:alpha:]][\\_\\#\\_\\$[:alnum:]]*)",
          "name": "entity.name.variable.parameter.usp"
        },
        {
          "include": "#declaration-skip"
        },
        {
          "include": "#comment"
        },
        {
          "include": "#punctuation-comma"
        },
        {
          "include": "#type-array-suffix"
        }
      ]
    },
    "variable-declaration": {
      "begin": "(?x)\n  (?=\n    ^   #start pattern at the beginning of a line\n    \\s* #ignore leading spaces\n    (?:\n      (?:[\\_[:alpha:]][\\_\\#\\_\\$[:alnum:]]*)\\s   #grab identifier\n    )\n    (?=[\\_[:alpha:]])  #only when followed by the beginning of another identifier\n  )          #without grabbing any characters",
      "end": "(?x)\n  (?<=;)|    #stop pattern after the semicolon or\n  (?=[{\\(]) #before curly bracket or parenthesis without grabbing any characters",
      "patterns": [
        {
          "begin": "(?ix)\n  (?:\\s*)\n  (dynamic|volatile|nonvolatile|ascii|utf16|inherit|delegateproperty)?\\s*  #Possibly grab modifier\n  (?:\n    (integer|string|long_integer|signed_integer|signed_long_integer|simplsharpstring)| #grab the built-in variable type or\n    (cevent|cmutex)| #or built in class\n    ([_[:alpha:]][\\#\\$\\_[:alnum:]]*)\\s* #grab the variable name\n  )",
          "beginCaptures": {
            "1": {
              "name": "keyword.modifier.variable.usp"
            },
            "2": {
              "name": "keyword.declaration.variable.usp"
            },
            "3": {
              "name": "keyword.support.class.usp"
            },
            "4": {
              "patterns": [
                {
                  "include": "#built-in-types"
                },
                {
                  "match": "([\\_[:alpha:]][\\_\\#\\_\\$[:alnum:]]*)",
                  "name": "entity.name.variable.usp"
                }
              ]
            }
          },
          "end": "(?ix)\n  (\\;)  #stop pattern before the closing curly brace or before semicolon without grabbing any characters",
          "endCaptures": {
            "1": {
              "name": "punctuation.terminator.variable.usp"
            }
          },
          "name": "meta.declaration.variable.usp",
          "patterns": [
            {
              "match": "([\\_[:alpha:]][\\_\\#\\_\\$[:alnum:]]*)",
              "name": "entity.name.variable.usp"
            },
            {
              "include": "#type-array-suffix"
            },
            {
              "include": "#comment"
            },
            {
              "include": "#punctuation-comma"
            }
          ]
        }
      ]
    },
    "structure-declaration": {
      "begin": "(?ix)\n  (?=\\bstructure\\b) #start pattern at the beginning of the word structure without grabbing any characters",
      "end": "(?ix)\n  (?<=};)   #stop pattern after the closing curly brace semicolon pair without grabbing any characters",
      "patterns": [
        {
          "begin": "(?ix)\n  \\b(structure)\\b\\s+\n  ([_[:alpha:]][\\#\\$\\_[:alnum:]]*)",
          "beginCaptures": {
            "1": {
              "name": "keyword.declaration.structure.usp"
            },
            "2": {
              "name": "entity.name.type.structure.usp"
            }
          },
          "end": "(?ix)\n  (?=\\{)|(?=;) #stop pattern after the opening curly brace or before semicolon without grabbing any characters",
          "name": "meta.declaration.structure.usp",
          "patterns": [
            {
              "include": "#comment"
            }
          ]
        },
        {
          "begin": "(\\{)",
          "beginCaptures": {
            "1": {
              "name": "punctuation.curlybrace.open.usp"
            }
          },
          "end": "(\\})\\s*(;)",
          "endCaptures": {
            "1": {
              "name": "punctuation.curlybrace.close.usp"
            },
            "2": {
              "name": "punctuation.terminator.structure.usp"
            }
          },
          "name": "meta.structure.contents",
          "patterns": [
            {
              "include": "#structure-members"
            },
            {
              "include": "#preprocessor"
            },
            {
              "include": "#comment"
            }
          ]
        }
      ]
    },
    "function-declaration": {
      "begin": "(?ix)\n  (?=(?:function|integer_function|string_function|long_integer_function|signed_integer_function|signed_long_integer_function|simplsharpstring)) #start pattern at the beginning of the function keyword without grabbing any characters",
      "end": "(?ix)\n  (?<!\\})\\}(?!\\})   #stop pattern after the closing curly brace without grabbing any characters only when there are no adjacent curly braces to avoid stopping at bitwise rotate right",
      "patterns": [
        {
          "begin": "(?ix)\n  (function|integer_function|string_function|long_integer_function|signed_integer_function|signed_long_integer_function|simplsharpstring)\\b\\s+\n  ([_[:alpha:]][\\#\\$\\_[:alnum:]]*)",
          "beginCaptures": {
            "1": {
              "name": "keyword.declaration.function.usp"
            },
            "2": {
              "name": "entity.name.variable.function.usp"
            }
          },
          "end": "(?ix)\n  (?=\\{) #stop pattern after the opening curly brace without grabbing any characters",
          "name": "meta.declaration.function.usp",
          "patterns": [
            {
              "include": "#parenthesized-parameter-list"
            }
          ]
        },
        {
          "begin": "({)",
          "beginCaptures": {
            "1": {
              "name": "punctuation.curlybrace.open.usp"
            }
          },
          "end": "(?<!\\})(\\})(?!\\})",
          "endCaptures": {
            "1": {
              "name": "punctuation.curlybrace.close.usp"
            }
          },
          "name": "meta.function.contents",
          "patterns": [
            {
              "include": "#preprocessor"
            },
            {
              "include": "#statement"
            },
            {
              "include": "#comment"
            },
            {
              "include": "#variable-declaration"
            }
          ]
        }
      ]
    },
    "event-declaration": {
      "begin": "(?ix)\n  (?=\n    (\\bthreadsafe\\b\\s+)? #Possibly grab threadsafe\n    (?:push|event|change|release|socketconnect|socketdisconnect|socketreceive|socketstatus|eventhandler)\n  ) #start pattern at the beginning of the function keyword without grabbing any characters",
      "end": "(?ix)\n  (?<=})   #stop pattern after the closing curly brace without grabbing any characters",
      "patterns": [
        {
          "begin": "(?ix)\n  (\\bthreadsafe\\b\\s+)?\n  (push|event|change|release|socketconnect|socketdisconnect|socketreceive|socketstatus|eventhandler)\\b\\s+",
          "beginCaptures": {
            "1": {
              "name": "keyword.modifier.event.usp"
            },
            "2": {
              "name": "keyword.declaration.event.usp"
            },
            "3": {
              "name": "entity.name.variable.event.usp"
            }
          },
          "end": "(?ix)\n  (?=\\{) #stop pattern after the opening curly brace without grabbing any characters",
          "name": "meta.declaration.event.usp",
          "patterns": [
            {
              "match": "([\\_[:alpha:]][\\_\\#\\_\\$[:alnum:]]*)",
              "name": "entity.name.variable.event.usp"
            },
            {
              "include": "#punctuation-comma"
            },
            {
              "include": "#comment"
            },
            {
              "include": "#parenthesized-parameter-list"
            }
          ]
        },
        {
          "begin": "(\\{)",
          "beginCaptures": {
            "1": {
              "name": "punctuation.curlybrace.open.usp"
            }
          },
          "end": "(\\})",
          "endCaptures": {
            "1": {
              "name": "punctuation.curlybrace.close.usp"
            }
          },
          "name": "meta.event.contents",
          "patterns": [
            {
              "match": "(?i)\\bTerminateEvent\\b",
              "name": "keyword.control.event.terminate.usp"
            },
            {
              "include": "#statement"
            },
            {
              "include": "statement"
            },
            {
              "include": "#preprocessor"
            },
            {
              "include": "#comment"
            }
          ]
        }
      ]
    },
    "callback-declaration": {
      "begin": "(?ix)\n  (?=\n    (\\bcallback\\b\\s+)? #test for callback\n    (?:function|integer_function|string_function|long_integer_function|signed_integer_function|signed_long_integer_function|simplsharpstring)\n  ) #start pattern at the beginning of the callback function keyword without grabbing any characters",
      "end": "(?ix)\n  (?<=})   #stop pattern after the closing curly brace without grabbing any characters",
      "patterns": [
        {
          "begin": "(?ix)\n  (\\bcallback\\b\\s+)? #grab the callback keyword\n  (function|integer_function|string_function|long_integer_function|signed_integer_function|signed_long_integer_function|simplsharpstring)\\b\\s+\n  ([_[:alpha:]][\\#\\$\\_[:alnum:]]*)",
          "beginCaptures": {
            "1": {
              "name": "keyword.declaration.callback.usp"
            },
            "2": {
              "name": "keyword.declaration.function.usp"
            },
            "3": {
              "name": "entity.name.variable.function.usp"
            }
          },
          "end": "(?ix)\n  (?=\\{) #stop pattern after the opening curly brace without grabbing any characters",
          "name": "meta.declaration.function.usp",
          "patterns": [
            {
              "include": "#comment"
            },
            {
              "include": "#parenthesized-parameter-list"
            }
          ]
        },
        {
          "begin": "(\\{)",
          "beginCaptures": {
            "1": {
              "name": "punctuation.curlybrace.open.usp"
            }
          },
          "end": "(\\})",
          "endCaptures": {
            "1": {
              "name": "punctuation.curlybrace.close.usp"
            }
          },
          "name": "meta.callback.contents",
          "patterns": [
            {
              "include": "#statement"
            },
            {
              "include": "#variable-declaration"
            },
            {
              "include": "statement"
            },
            {
              "include": "#preprocessor"
            },
            {
              "include": "#comment"
            }
          ]
        }
      ]
    },
    "namespace-declaration": {
      "begin": "(?ix)\n  (?=\\bnamespace\\b) #start pattern at the beginning of the word structure without grabbing any characters",
      "end": "(?ix)\n  (?<=\\})   #stop pattern after the closing curly brace without grabbing any characters",
      "patterns": [
        {
          "begin": "(?ix)\n  \\b(namespace)\\b\\s+\n  ([_[:alpha:]][\\#\\$\\_[:alnum:]]*)",
          "beginCaptures": {
            "1": {
              "name": "keyword.declaration.namespace.usp"
            },
            "2": {
              "name": "entity.name.type.namespace.usp"
            }
          },
          "end": "(?ix)\n  (?=\\{) #stop pattern before the opening curly brace without grabbing any characters",
          "name": "meta.declaration.namespace.usp",
          "patterns": [
            {
              "include": "#comment"
            }
          ]
        },
        {
          "begin": "(\\{)",
          "beginCaptures": {
            "1": {
              "name": "punctuation.curlybrace.open.usp"
            }
          },
          "end": "(\\})(?!;)",
          "endCaptures": {
            "1": {
              "name": "punctuation.curlybrace.close.usp"
            }
          },
          "name": "meta.namespace.contents",
          "patterns": [
            {
              "include": "#class-declaration"
            },
            {
              "include": "#comment"
            }
          ]
        }
      ]
    },
    "class-declaration": {
      "begin": "(?ix)\n  (?=\n    (\\bstatic\\b\\s+)?\n    \\bclass\\b\n  ) #start pattern at the beginning of the word (static)? class  without grabbing any characters",
      "end": "(?ix)\n  (?<=};)   #stop pattern after the closing curly brace semicolon pair without grabbing any characters",
      "patterns": [
        {
          "begin": "(?ix)\n  (?:\\b(static)\\b\\s+)?               #possibly grab static\n  \\b(class)\\b\\s+                    #grab the word structure\n  ([_[:alpha:]][\\#\\$\\_[:alnum:]]*)  #grab the structure name",
          "beginCaptures": {
            "1": {
              "name": "keyword.modifier.class.usp"
            },
            "2": {
              "name": "keyword.declaration.class.usp"
            },
            "3": {
              "name": "entity.name.type.class.usp"
            }
          },
          "end": "(?ix)\n  (?=\\{) #stop pattern before the opening curly brace or before semicolon without grabbing any characters",
          "patterns": [
            {
              "include": "#comment"
            }
          ],
          "name": "meta.declaration.class.usp"
        },
        {
          "begin": "(\\{)",
          "beginCaptures": {
            "1": {
              "name": "punctuation.curlybrace.open.usp"
            }
          },
          "end": "(\\})(;)",
          "endCaptures": {
            "1": {
              "name": "punctuation.curlybrace.close.usp"
            },
            "2": {
              "name": "punctuation.terminator.class.usp"
            }
          },
          "name": "meta.class.contents",
          "patterns": [
            {
              "include": "#class-delegate-declaration"
            },
            {
              "include": "#class-eventhandler-declaration"
            },
            {
              "include": "#class-function-declaration"
            },
            {
              "include": "#variable-declaration"
            },
            {
              "include": "#comment"
            }
          ]
        }
      ]
    },
    "class-delegate-declaration": {
      "name": "meta.declaration.class.delegate.usp",
      "begin": "(?ix)\n  (?=\n    (\\bstatic\\b\\s+)?\n    \\bdelegate\\bs*\n  ) #start pattern at the beginning of the delegate keyword without grabbing any characters",
      "end": "(?ix)\n  (?<=\\;)   #stop pattern before semicolon without grabbing any characters",
      "patterns": [
        {
          "begin": "(?ix)\n  (?:\\b(static)\\b\\s+)?              #possibly grab static\n  \\b(delegate)\\b\\s+                 #grab the word delegate\n  \\b(function|integer_function|string_function|long_integer_function|signed_integer_function|signed_long_integer_function|SIMPLSHARPSTRING_FUNCTION)\\b\\s+ #grab delegate type\n  ([_[:alpha:]][\\#\\$\\_[:alnum:]]*)   #grab the delegate name",
          "beginCaptures": {
            "1": {
              "name": "keyword.modifier.delegate.usp"
            },
            "2": {
              "name": "keyword.declaration.delegate.usp"
            },
            "3": {
              "name": "keyword.declaration.function.usp"
            },
            "4": {
              "name": "entity.name.variable.delegate.usp"
            }
          },
          "end": "(;)",
          "endCaptures": {
            "1": {
              "name": "punctuation.terminator.delegate.usp"
            }
          },
          "patterns": [
            {
              "include": "#comment"
            },
            {
              "include": "#parenthesized-parameter-list"
            }
          ]
        }
      ]
    },
    "class-eventhandler-declaration": {
      "name": "meta.declaration.class.eventhandler.usp",
      "begin": "(?ix)\n  (?=\n    \\beventhandler\\b\n  ) #start pattern at the beginning of the eventhandler keyword without grabbing any characters",
      "end": "(?ix)\n  (?<=\\;)   #stop pattern after semicolon without grabbing any characters",
      "patterns": [
        {
          "begin": "(?ix)\n  \\b(eventhandler)\\b\\s+              #grab the word eventhandler\n  ([_[:alpha:]][\\#\\$\\_[:alnum:]]*)   #grab the delegate name",
          "beginCaptures": {
            "1": {
              "name": "keyword.modifier.eventhandler.usp"
            },
            "2": {
              "name": "entity.name.variable.eventhandler.usp"
            }
          },
          "end": "(;)",
          "endCaptures": {
            "1": {
              "name": "punctuation.terminator.eventhandler.usp"
            }
          },
          "patterns": [
            {
              "include": "#comment"
            },
            {
              "include": "#parenthesized-parameter-list"
            }
          ]
        }
      ]
    },
    "class-function-declaration": {
      "name": "meta.declaration.class.function.usp",
      "begin": "(?ix)\n  (?=(?:function|integer_function|string_function|long_integer_function|signed_integer_function|signed_long_integer_function|SIMPLSHARPSTRING_FUNCTION)) #start pattern at the beginning of the function keyword without grabbing any characters",
      "end": "(?ix)\n  (?<=;)   #stop pattern after the closing curly brace or before semicolon without grabbing any characters",
      "patterns": [
        {
          "begin": "(?ix)\n  (function|integer_function|string_function|long_integer_function|signed_integer_function|signed_long_integer_function|SIMPLSHARPSTRING_FUNCTION)\\b\\s+\n  ([_[:alpha:]][\\#\\$\\_[:alnum:]]*)",
          "beginCaptures": {
            "1": {
              "name": "keyword.declaration.function.usp"
            },
            "2": {
              "name": "entity.name.variable.function.usp"
            }
          },
          "end": "(;)",
          "endCaptures": {
            "1": {
              "name": "punctuation.terminator.function.usp patterns"
            }
          },
          "patterns": [
            {
              "include": "#preprocessor"
            },
            {
              "include": "#comment"
            },
            {
              "include": "#parenthesized-parameter-list"
            }
          ]
        }
      ]
    },
    "structure-members": {
      "patterns": [
        {
          "include": "#variable-declaration"
        }
      ]
    },
    "parenthesized-parameter-list": {
      "name": "meta.parameters",
      "begin": "(\\()",
      "beginCaptures": {
        "0": {
          "name": "punctuation.parenthesis.open.usp"
        }
      },
      "end": "(\\))",
      "endCaptures": {
        "0": {
          "name": "punctuation.parenthesis.close.usp"
        }
      },
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "include": "#parameter"
        },
        {
          "include": "#punctuation-comma"
        }
      ]
    },
    "parameter": {
      "begin": "(?ix)\n    \\s*(ByVal|ByRef|ReadOnlyByRef)?\\s*  #Possibly grab modifier\n    (?:\n      (integer|string|long_integer|signed_integer|signed_long_integer|SIMPLSHARPSTRING|eventargs)| #grab the variable type or\n      ([_[:alpha:]][\\#\\$\\_[:alnum:]]*) #grab the type\n    )",
      "beginCaptures": {
        "1": {
          "name": "keyword.modifier.parameter.usp"
        },
        "2": {
          "name": "keyword.declaration.parameter.usp"
        },
        "3": {
          "name": "entity.name.type.usp"
        }
      },
      "end": "(?ix)\n  (?=[\\,\\)])  #stop pattern before theres a comma or closing parenthesis without grabbing any characters",
      "patterns": [
        {
          "match": "([\\_[:alpha:]][\\_\\#\\_\\$[:alnum:]]*)",
          "name": "entity.name.variable.usp"
        },
        {
          "include": "#type-array-suffix"
        }
      ]
    },
    "type-array-suffix": {
      "begin": "\\[",
      "beginCaptures": {
        "0": {
          "name": "punctuation.squarebracket.open.usp"
        }
      },
      "end": "\\]",
      "endCaptures": {
        "0": {
          "name": "punctuation.squarebracket.close.usp"
        }
      },
      "patterns": [
        {
          "include": "#numeric-literal"
        },
        {
          "include": "#punctuation-comma"
        }
      ]
    },
    "statement": {
      "patterns": [
        {
          "include": "#preprocessor"
        },
        {
          "include": "#comment"
        },
        {
          "include": "#expression"
        }
      ]
    },
    "branching-and-decision": {
      "patterns": [
        {
          "include": "#while-statement"
        }
      ]
    },
    "while-statement": {
      "begin": "(?ix)\n  \\b(while)\\b\\s*(?=\\() #Keyword",
      "beginCaptures": {
        "1": {
          "name": "keyword.control.loop.while.usp"
        }
      },
      "end": "(?<=\\})",
      "patterns": [
        {
          "begin": "\\(",
          "beginCaptures": {
            "0": {
              "name": "punctuation.definition.parameters.begin.usp"
            }
          },
          "end": "\\)",
          "endCaptures": {
            "0": {
              "name": "punctuation.definition.parameters.end.usp"
            }
          },
          "patterns": [
            {
              "include": "#expression"
            }
          ]
        },
        {
          "include": "#statement"
        }
      ]
    },
    "expression": {
      "patterns": [
        {
          "include": "#assignment-expression"
        },
        {
          "include": "#expression-no-assignment"
        }
      ]
    },
    "expression-no-assignment": {
      "patterns": [
        {
          "include": "#preprocessor"
        },
        {
          "include": "#comment"
        },
        {
          "include": "#invocation-expression"
        },
        {
          "include": "#element-access-expression"
        },
        {
          "include": "#built-in-constants"
        },
        {
          "include": "#literals"
        },
        {
          "include": "#type-name"
        },
        {
          "include": "#parenthesized-expression"
        }
      ]
    },
    "invocation-expression": {
      "begin": "(?xi)\n  (\\.)?\\s*  # possibly grab dot from a SIMPL# type\n  \\b([\\_[:alpha:]][\\_\\#\\_\\$[:alnum:]]*)\\b\\s* #grab the function name  \n  (?=\\() #stop pattern before the opening parenthesis without grabbing any characters",
      "beginCaptures": {
        "1": {
          "name": "punctuation.accessor.usp"
        },
        "2": {
          "patterns": [
            {
              "include": "#builtin-functions"
            },
            {
              "include": "#built-in-void-functions"
            },
            {
              "match": "(?xi)[\\_[:alpha:]][\\_\\#\\_\\$[:alnum:]]*",
              "name": "entity.name.function.usp"
            }
          ]
        }
      },
      "end": "(?xi)\n  (;) #stop pattern after the closing parenthesis without grabbing any characters",
      "endCaptures": {
        "1": {
          "name": "punctuation.terminator.invocation.usp"
        }
      },
      "patterns": [
        {
          "include": "#argument-list"
        }
      ]
    },
    "builtin-functions": {
      "patterns": [
        {
          "include": "#functions-data-conversion"
        },
        {
          "include": "#functions-random-number"
        },
        {
          "include": "#functions-string-parsing"
        },
        {
          "include": "#functions-mathematical"
        },
        {
          "include": "#functions-bit-and-byte"
        },
        {
          "include": "#functions-file"
        },
        {
          "include": "#functions-time-and-date"
        },
        {
          "include": "#functions-system-interfacing"
        },
        {
          "include": "#functions-direct-socket-access"
        },
        {
          "include": "#functions-email"
        },
        {
          "include": "#functions-ramping"
        },
        {
          "include": "#functions-encoding"
        },
        {
          "include": "#functions-array-operations"
        },
        {
          "include": "#functions-exception-handling"
        },
        {
          "include": "#functions-bitwise"
        }
      ]
    },
    "functions-data-conversion": {
      "match": "(?i)\\b(Atoi|Atosi|Atol|Atosl|Chr|HexToI|HexToL|HexToSI|HexToSL|Itoa|Itohex|Ltoa|Ltohex)\\b",
      "name": "keyword.support.function.usp"
    },
    "functions-random-number": {
      "match": "(?i)\\b(Random|Rnd)\\b",
      "name": "keyword.support.function.usp"
    },
    "functions-string-parsing": {
      "match": "(?ix)\n  \\b(CompareStrings|CompareStringsNoCase|Find|\n  FindNoCase|Gather|GatherByLength|GatherAsync|GatherAsyncByLength|GatherByLengthWithDest|ReArmGatherAsync|RemoveGatherAsync|\n  GetC|Left|Len|Lower|Upper|Mid|Remove|RemoveByLength|ResizeString|ReverseFind|ReverseFindNoCase|Right|SetString)\\b",
      "name": "keyword.support.function.usp"
    },
    "functions-mathematical": {
      "match": "(?i)\\b(abs|max|min|muldiv|smax|smin)\\b",
      "name": "keyword.support.function.usp"
    },
    "functions-bit-and-byte": {
      "match": "(?i)\\b(Bit|Byte|High|HighWord|Low|LowWord|LowerChar|RotateLeft|RotateLeftLong|RotateRight|RotateRightLong|SetByte|UpperChar)\\b",
      "name": "keyword.support.function.usp"
    },
    "functions-file": {
      "match": "(?ix)\n  \\b(FileBOF|FileClose|FileDelete|FileDeleteShared|FileEOF|FileLength|CheckForDisk|GetCurrentDirectory|\n  FileOpen|FileOpenShared|FileRead|FileSeek|FileWrite|FindClose|FindFirst|FindFirstShared|FindNext|\n  IsDirectory|IsHidden|IsReadOnly|IsSystem|IsVolume|MakeDirectory|MakeDirectoryShared|ReadInteger|\n  ReadIntegerArray|ReadLongInteger|ReadLongIntegerArray|ReadSignedInteger|ReadSignedIntegerArray|\n  ReadSignedLongInteger|ReadSignedLongIntegerArray|ReadString|ReadStringArray|CheckForNVRAMDisk|\n  RemoveDirectory|RemoveDirectoryShared|SetCurrentDirectory|StartFileOperations|EndFileOperations|WaitForNewDisk|\n  WriteInteger|WriteIntegerArray|WriteLongInteger|WriteLongIntegerArray|WriteSignedInteger|\n  WriteSignedIntegerArray|WriteSignedLongInteger|WriteSignedLongIntegerArray|WriteString|WriteStringArray)\\b",
      "name": "keyword.support.function.usp"
    },
    "functions-time-and-date": {
      "match": "(?ix)\n  \\b(Date|Day|FileDate|FileDay|FileGetDateNum|FileGetDayOfWeekNum|FileGetHourNum|\n  FileGetMinutesNum|FileGetMonthNum|FileGetSecondsNum|FileGetYearNum|FileMonth|FileTime|GetDateNum|\n  GetDayOfWeekNum|GetDST|GetGMTOffset|GetHourNum|GetHSeconds|GetMinutesNum|GetMonthNum|GetSecondsNum|\n  GetTicks|GetYearNum|month|SetGMTOffset|Time)\\b",
      "name": "keyword.support.function.usp"
    },
    "functions-direct-socket-access": {
      "match": "(?ix)\n\\b(SocketConnectClient|SocketDisconnectClient|\nSocketGetAddressAsRequested|SocketGetPortNumber|SocketGetRemoteIPAddress|SocketGetSenderIPAddress|\nSocketGetStatus|SocketIsBroadcast|SocketIsMulticast|SocketSend|SocketServerStartListen|\nSocketServerStopListen|SocketUDP_Disable|SocketUDP_Enable)\\b",
      "name": "keyword.support.function.usp"
    },
    "functions-email": {
      "match": "(?i)\\b(SendMail|SendMailAdvance|SendMailWithAttachments)\\b",
      "name": "keyword.support.function.usp"
    },
    "functions-ramping": {
      "match": "(?ix)\n  \\b(CompareRampsByAttribute|CompareRampsByID|CreateRamp|GetRampInfo|\n  IsRamping|RAMP_INFO|StopRamp)\\b",
      "name": "keyword.support.function.usp"
    },
    "functions-encoding": {
      "match": "(?i)\\b(GetEncoding|SetEncoding|ToAscii|ToUtf16)\\b",
      "name": "keyword.support.function.usp"
    },
    "functions-system-interfacing": {
      "match": "(?ix)\n  \\b(GetSlot|GetCresnet|GetCIP|GetSymbolInstanceName|GetSymbolReferenceName|MakeProgramFilename|GetModelNumber|GetSeries|\n  IsSignalDefined)\\b",
      "name": "keyword.support.function.usp"
    },
    "functions-array-operations": {
      "match": "(?ix)\n  \\b(GetLastModifiedArrayIndex|GetNumArrayCols|GetNumArrayRows|GetNumStructureArrayCols|\n  ResizeArray|ResizeStructureArray)\\b",
      "name": "keyword.support.function.usp"
    },
    "functions-exception-handling": {
      "match": "(?i)\\b(GetExceptionCode|GetExceptionMessage)\\b",
      "name": "keyword.support.function.usp"
    },
    "functions-bitwise": {
      "match": "(?i)\\b(not)\\b",
      "name": "keyword.support.function.usp"
    },
    "built-in-void-functions": {
      "patterns": [
        {
          "include": "#void-functions-random-number"
        },
        {
          "include": "#void-functions-string-parsing"
        },
        {
          "include": "#void-functions-file"
        },
        {
          "include": "#void-functions-system-control"
        },
        {
          "include": "#void-functions-time-and-date"
        },
        {
          "include": "#void-functions-system-interfacing"
        },
        {
          "include": "#void-functions-wait"
        },
        {
          "include": "#void-functions-string-formatting-and-printing"
        },
        {
          "include": "#void-functions-ramping"
        },
        {
          "include": "#void-functions-encoding"
        },
        {
          "include": "#void-functions-array-operations"
        },
        {
          "include": "#void-functions-delegate-handling"
        },
        {
          "include": "#void-functions-event-handling"
        }
      ]
    },
    "void-functions-random-number": {
      "match": "(?i)\\b(Seed)\\b",
      "name": "keyword.support.function.usp"
    },
    "void-functions-string-parsing": {
      "match": "(?ix)\\b(ClearBuffer)\\b",
      "name": "keyword.support.function.usp"
    },
    "void-functions-system-control": {
      "match": "(?ix)\\b(delay|ProcessLogic|pulse|WaitForInitializationComplete)\\b",
      "name": "keyword.support.function.usp"
    },
    "void-functions-system-interfacing": {
      "match": "(?ix)\\b(GenerateUserNotice|GenerateUserWarning|GenerateUserError|SendPacketToCPU|SendCresnetPacket|SetCresnet|SetSlot|SetCIP)\\b",
      "name": "keyword.support.function.usp"
    },
    "void-functions-wait": {
      "match": "(?i)\\b(CancelAllWait|CancelWait|PauseAllWait|PauseWait|ResumeAllWait|ResumeWait|RetimeWait)\\b",
      "name": "keyword.support.function.usp"
    },
    "void-functions-string-formatting-and-printing": {
      "match": "(?i)\\b(Makestring|Print|Trace)\\b",
      "name": "keyword.support.function.usp"
    },
    "void-functions-file": {
      "match": "(?ix)\\b(ReadStructure|WriteStructure)\\b",
      "name": "keyword.support.function.usp"
    },
    "void-functions-time-and-date": {
      "match": "(?ix)\\b(SetDate|SetClock)\\b",
      "name": "keyword.support.function.usp"
    },
    "void-functions-ramping": {
      "match": "(?ix)\\b(InitializeRampInfoArray|InitializeRampInfo)\\b",
      "name": "keyword.support.function.usp"
    },
    "void-functions-encoding": {
      "match": "(?i)\\b(SetEncoding)\\b",
      "name": "keyword.support.function.usp"
    },
    "void-functions-delegate-handling": {
      "match": "(?i)\\b(RegisterDelegate)\\b",
      "name": "keyword.support.function.usp"
    },
    "void-functions-event-handling": {
      "match": "(?i)\\b(RegisterEvent)\\b",
      "name": "keyword.support.function.usp"
    },
    "void-functions-array-operations": {
      "match": "(?ix)\\b(SetArray)\\b",
      "name": "keyword.support.function.usp"
    },
    "built-in-variables": {
      "match": "(?ix)\n  \\b(_oem_break|_oem_cd|_oem_cts|_oem_dtr|_oem_long_break|_oem_max_string|_oem_pacing|\n  _oem_rts|_oem_str_in|_oem_str_out|FILE_INFO)\\b",
      "name": "keyword.support.variable.usp"
    },
    "built-in-types": {
      "match": "(?ix)\n  \\b(FILE_INFO|ramp_info)\\b",
      "name": "keyword.support.variable.usp"
    },
    "built-in-constants": {
      "match": "(?ix)\n  \\b(_O_APPEND|_O_CREAT|_O_EXCL|_O_TRUNC|_O_TEXT|_O_BINARY|_O_RDONLY|_O_RDWR|_O_WRONLY|ARDONLY|AHIDDEN|ASYSTEM|AVOLUME|ADIRENT|ARCHIVE|ON|OFF)\\b",
      "name": "keyword.support.constant.usp"
    },
    "type-name": {
      "patterns": [
        {
          "match": "([_[:alpha:]][\\_\\#\\_\\$[:alnum:]]*)\\s*(\\.)",
          "captures": {
            "1": {
              "name": "entity.name.type.usp"
            },
            "2": {
              "name": "punctuation.accessor.usp"
            }
          }
        },
        {
          "match": "(\\.)\\s*([_[:alpha:]][\\_\\#\\_\\$_[:alnum:]]*)(?![<>])",
          "captures": {
            "1": {
              "name": "punctuation.accessor.usp"
            },
            "2": {
              "name": "entity.name.type.usp"
            }
          }
        },
        {
          "name": "entity.name.type.usp",
          "match": "([_[:alpha:]][\\_\\#\\_\\$_[:alnum:]]*)(?![<>])"
        }
      ]
    },
    "bracketed-argument-list": {
      "begin": "\\[",
      "beginCaptures": {
        "0": {
          "name": "punctuation.squarebracket.open.usp"
        }
      },
      "end": "\\]",
      "endCaptures": {
        "0": {
          "name": "punctuation.squarebracket.close.usp"
        }
      },
      "patterns": [
        {
          "include": "#expression"
        },
        {
          "include": "#punctuation-comma"
        }
      ]
    },
    "argument-list": {
      "begin": "\\(",
      "beginCaptures": {
        "0": {
          "name": "punctuation.parenthesis.open.usp"
        }
      },
      "end": "\\)",
      "endCaptures": {
        "0": {
          "name": "punctuation.parenthesis.close.usp"
        }
      },
      "patterns": [
        {
          "include": "#named-argument"
        },
        {
          "include": "#expression"
        },
        {
          "include": "#punctuation-comma"
        }
      ]
    },
    "named-argument": {
      "match": "(@?[_[:alpha:]][_[:alnum:]]*)",
      "name": "entity.name.variable.parameter.cs"
    },
    "assignment-expression": {
      "begin": "(?:([\\_[:alpha:]][\\_\\#\\_\\$[:alnum:]]*)\\s*)(=)",
      "beginCaptures": {
        "1": {
          "name": "entity.name.type.usp"
        },
        "2": {
          "name": "keyword.operator.assignment.usp"
        }
      },
      "end": "(?<=;)",
      "patterns": [
        {
          "include": "#expression-operator"
        },
        {
          "include": "#expression-no-assignment"
        }
      ]
    },
    "expression-operator": {
      "patterns": [
        {
          "name": "keyword.operator.relational.usp",
          "match": "<=|>=|<|>|S<=|S>=|S<|S>"
        },
        {
          "name": "keyword.operator.arithmetic.usp",
          "match": "(?i)\\+|\\-|\\*|\\/|S\\/|%|mod|umod"
        },
        {
          "name": "keyword.operator.bitwise.shift.usp",
          "match": "<<|>>"
        },
        {
          "name": "keyword.operator.bitwise.rotate.usp",
          "match": "\\{\\{|\\}\\}"
        },
        {
          "name": "keyword.operator.bitwise.usp",
          "match": "(?i)\\&|\\^|\\|"
        },
        {
          "name": "keyword.operator.bitwise.usp",
          "match": "\\!|&&|\\|\\|"
        },
        {
          "match": "(=)",
          "name": "keyword.operator.comparison.usp"
        },
        {
          "match": "<>",
          "name": "keyword.operator.relational.usp"
        }
      ]
    },
    "element-access-expression": {
      "begin": "(?x)\n  (?:([\\_[:alpha:]][\\_\\#\\_\\$[:alnum:]]*)\\s*) # property name\n  (?=\\[)                              # open bracket of argument list",
      "beginCaptures": {
        "1": {
          "name": "entity.name.type.usp"
        }
      },
      "end": "(?<=\\])(?!\\s*\\[)",
      "patterns": [
        {
          "include": "#bracketed-argument-list"
        }
      ]
    },
    "parenthesized-expression": {
      "begin": "\\(",
      "beginCaptures": {
        "0": {
          "name": "punctuation.parenthesis.open.cs"
        }
      },
      "end": "\\)",
      "endCaptures": {
        "0": {
          "name": "punctuation.parenthesis.close.cs"
        }
      },
      "patterns": [
        {
          "include": "#expression"
        }
      ]
    },
    "literals": {
      "patterns": [
        {
          "include": "#numeric-literal"
        },
        {
          "include": "#char-literal"
        },
        {
          "include": "#string-literal"
        }
      ]
    },
    "numeric-literal": {
      "match": "(?x)\n  (?<!\\w)\\.?\\d #ensure it starts with a digit or period and not a word character\n  (?:\n    (?:[0-9a-zA-Z_%]|_)| #capture any digit or letter or underscore (anything that resembles a number)\n    (?<=[eE])[+-]| # even if it looks scientific\n    \\.\\d #or floating point\n  )*",
      "captures": {
        "0": {
          "patterns": [
            {
              "begin": "(?=.)",
              "end": "$",
              "patterns": [
                {
                  "match": "(?x)\n  (0[xX]) #ensure it starts with a 0x or 0X\n  ([0-9a-fA-F](?:[0-9a-fA-F])*)$ #capture rest of hex digits",
                  "captures": {
                    "1": {
                      "name": "constant.numeric.other.prefix.hex.usp"
                    },
                    "2": {
                      "name": "constant.numeric.hex.usp"
                    }
                  }
                },
                {
                  "match": "(?x)\n  (?=[0-9])(?!0[xX]) #ensure it starts with a digit, but not wit a 0x or 0X \n  ([0-9d](?:[0-9d])*)$ #capture rest of decimal digits and d (for parameter properties decimal value)",
                  "captures": {
                    "1": {
                      "name": "constant.numeric.decimal.usp"
                    }
                  }
                },
                {
                  "match": "(?ix)\n  (?=[0-9a-f])(?!0[xX]) #ensure it starts with a hex digit, but not wit a 0x or 0X \n  ([0-9a-fh](?:[0-9a-fh])*)$ #capture rest of hex digits and h (for parameter properties decimal value)hex value)",
                  "captures": {
                    "1": {
                      "name": "constant.numeric.hex.usp"
                    }
                  }
                },
                {
                  "match": "(?x)\n  (?=[0-9])(?!0[xX]) #ensure it starts with a digit, but not wit a 0x or 0X \n  ([0-9%](?:[0-9%])*)$ #capture rest of decimal digits and % (for parameter properties percentage value)",
                  "captures": {
                    "1": {
                      "name": "constant.numeric.percentage.usp"
                    }
                  }
                },
                {
                  "match": "(?x)\n  (?=[0-9])(?!0[xX]) #ensure it starts with a digit, but not wit a 0x or 0X \n  ([0-9s](?:[0-9s])*)$ #capture rest of decimal digits and s (for parameter properties seconds value)",
                  "captures": {
                    "1": {
                      "name": "constant.numeric.seconds.usp"
                    }
                  }
                },
                {
                  "match": "(?x)\n  (?=[0-9])(?!0[xX]) #ensure it starts with a digit, but not wit a 0x or 0X \n  ([0-9t](?:[0-9t])*)$ #capture rest of decimal digits and t (for parameter properties ticks value)",
                  "captures": {
                    "1": {
                      "name": "constant.numeric.ticks.usp"
                    }
                  }
                },
                {
                  "match": "(?:(?:[0-9a-zA-Z_]|_)|(?<=[eE])[+-]|\\.\\d)+",
                  "name": "invalid.illegal.constant.numeric.usp"
                }
              ]
            }
          ]
        }
      }
    },
    "char-literal": {
      "name": "string.quoted.single.usp",
      "begin": "\\'",
      "beginCaptures": {
        "0": {
          "name": "punctuation.definition.char.begin.usp"
        }
      },
      "end": "(\\')|((?:[^\\n])$)",
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.char.end.usp"
        },
        "2": {
          "name": "invalid.illegal.newline.usp"
        }
      },
      "patterns": [
        {
          "match": "([0-9a-zA-Z]{2,})",
          "name": "invalid.illegal.char.usp"
        }
      ]
    },
    "string-literal": {
      "name": "string.quoted.double.usp",
      "begin": "\\\"",
      "beginCaptures": {
        "0": {
          "name": "punctuation.definition.string.begin.usp"
        }
      },
      "end": "(\")|((?:[^\\n])$)",
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.string.end.usp"
        },
        "2": {
          "name": "invalid.illegal.newline.usp"
        }
      },
      "patterns": [
        {
          "include": "#string-character-escape"
        }
      ]
    },
    "string-character-escape": {
      "match": "(?x)\n  (\\%   #escape initializer character either % or \\\n    (?:\n      (?:[0-9a-zA-Z]|\\%)? #grab any digit or letter or % character for next character zero or 1 times\n      (?:[0-9a-zA-Z])*    #grab the rest of the digits or letters\n    )\n  ) |  #or\n  (?:\\\\(?:[a-zA-Z])(?:(?:[0-9a-fA-F]){2})?)|(?:\\\\\\\\) #grab any one letter or dual hex number after a backslash or double backslash",
      "captures": {
        "0": {
          "patterns": [
            {
              "begin": "(?=.)",
              "end": "$",
              "patterns": [
                {
                  "match": "(?x)\n  (%%) |  # Prints % or\n  (%\n    (?:\n      (?:[0-9]?[0-9])? #[[pad]width]\n      (?:\n        d|  #Signed Analog_Input, Analog_Output or Integer as decimal\n        s|  #Buffer_Input, String_Input or String\n        u|  #Unsigned Analog_Input, Analog_Output or integer\n        ld| #Long_Integer as decimal\n        lu| #Long_Unsigned_Integer as decimal\n        x|  #Analog_Input, Analog_Output or Integer as lowercase hexadecimal\n        X|  #Analog_Input, Analog_Output or Integer as uppercase hexadecimal\n        lx| #long Integer as lowercase hexadecimal\n        lX| #long Integer as uppercase hexadecimal\n        c|  #Printable ASCII character\n      ){1}\n    ) #Print Formatters %[[pad]width]specifier\n  )",
                  "name": "constant.character.escape.usp"
                },
                {
                  "match": "(?x)\n   (\\\\\n     [\n       a  #Alert (Beep)\n       b  #Backspace\n       f  #Form Feed\n       n  #Newline\n       r  #Carriage Return\n       t  #Horizontal Tab\n       v\n     ] #Vertical Tab\n   ) |\n   (\\\\\n     (?:\n       [xX](?:[0-9a-fA-F]){2}  #Hexadecimal character code\n     )\n   ) |\n   (\\\\\\\\) #double backslash",
                  "name": "constant.character.escape.usp"
                },
                {
                  "match": ".*",
                  "name": "invalid.illegal.character.escape.usp"
                }
              ]
            }
          ]
        }
      }
    },
    "punctuation": {
      "patterns": [
        {
          "include": "#punctuation-grouping"
        },
        {
          "include": "#punctuation-structure"
        }
      ]
    },
    "punctuation-grouping": {
      "patterns": [
        {
          "include": "#punctuation-square-bracket"
        },
        {
          "include": "punctuation-parenthesis"
        },
        {
          "include": "punctuation-curlybrace"
        }
      ]
    },
    "punctuation-structure": {
      "patterns": [
        {
          "include": "#punctuation-comma"
        },
        {
          "include": "#punctuation-semicolon"
        },
        {
          "include": "#punctuation-parenthesis"
        },
        {
          "include": "#punctuation-accessor"
        },
        {
          "include": "#punctuation-dot"
        },
        {
          "include": "#punctuation-pipe"
        }
      ]
    },
    "punctuation-square-bracket": {
      "begin": "\\[",
      "beginCaptures": {
        "0": {
          "name": "punctuation.squarebracket.open.usp"
        }
      },
      "end": "\\]",
      "endCaptures": {
        "0": {
          "name": "punctuation.squarebracket.close.usp"
        }
      },
      "patterns": [
        {
          "include": "#intrusive"
        },
        {
          "include": "#punctuation-comma"
        }
      ]
    },
    "punctuation-curlybrace": {
      "begin": "\\{",
      "beginCaptures": {
        "0": {
          "name": "punctuation.curlybrace.open.usp"
        }
      },
      "end": "\\}",
      "endCaptures": {
        "0": {
          "name": "punctuation.curlybrace.close.usp"
        }
      },
      "patterns": [
        {
          "include": "#intrusive"
        },
        {
          "include": "#punctuation-comma"
        }
      ]
    },
    "punctuation-parenthesis": {
      "begin": "(\\()",
      "beginCaptures": {
        "0": {
          "name": "punctuation.parenthesis.open.usp"
        }
      },
      "end": "(\\))",
      "endCaptures": {
        "0": {
          "name": "punctuation.parenthesis.close.usp"
        }
      },
      "patterns": [
        {
          "include": "#expression"
        }
      ]
    },
    "punctuation-comma": {
      "match": "\\,",
      "name": "punctuation.comma.usp"
    },
    "punctuation-semicolon": {
      "match": "\\;",
      "name": "punctuation.terminator.usp"
    },
    "punctuation-dot": {
      "match": "(\\.)",
      "name": "punctuation.structure.dot.usp"
    },
    "punctuation-pipe": {
      "match": "(\\|)",
      "name": "punctuation.structure.pipe.usp"
    },
    "type": {
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "include": "#ref-modifier"
        },
        {
          "include": "#type-name"
        }
      ]
    },
    "designation-pattern": {
      "patterns": [
        {
          "include": "#intrusive"
        },
        {
          "begin": "\\(",
          "beginCaptures": {
            "0": {
              "name": "punctuation.parenthesis.open.usp"
            }
          },
          "end": "\\)",
          "endCaptures": {
            "0": {
              "name": "punctuation.parenthesis.close.usp"
            }
          },
          "patterns": [
            {
              "include": "#punctuation-comma"
            },
            {
              "include": "#designation-pattern"
            }
          ]
        },
        {
          "include": "#simple-designation-pattern"
        }
      ]
    },
    "simple-designation-pattern": {
      "patterns": [
        {
          "match": "(?x)\n(?:\n  ([_[:alpha:]][\\#\\$\\_[:alnum:]]*) #Name\n  (?:\\s*                   # array suffix?\n    (?:(\\[)\\d*(\\])\\s*)\n    (?:(\\[)\\d*(\\])\\s*)?\n  )?\n)",
          "captures": {
            "1": {
              "name": "entity.name.variable.local.usp"
            },
            "2": {
              "name": "punctuation.squarebracket.open.usp"
            },
            "3": {
              "name": "punctuation.squarebracket.close.usp"
            },
            "4": {
              "name": "punctuation.squarebracket.open.usp"
            },
            "5": {
              "name": "punctuation.squarebracket.close.usp"
            }
          }
        }
      ]
    }
  }
}