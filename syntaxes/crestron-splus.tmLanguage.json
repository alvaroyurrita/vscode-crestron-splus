{
  "scopeName": "source.splus",
  "fileTypes": [
    "usp",
    "usl",
    "csp",
    "csl"
  ],
  "name": "Crestron",
  "patterns": [
    {
      "include": "#preprocessor"
    },
    {
      "include": "#script-top-level"
    },
    {
      "include": "#comment"
    }
  ],
  "repository": {
    "script-top-level": {
      "patterns": [
        {
          "include": "#statement"
        }
      ]
    },
    "statement": {
      "patterns": [
        {
          "include": "#expression"
        },
        {
          "include": "#local-declarations"
        }
      ]
    },
    "expression": {
      "patterns": [
        {
          "include": "#preprocessor"
        },
        {
          "include": "#comment"
        },
        {
          "include": "#expression-operator-expression"
        },
        {
          "include": "#assignment-expression"
        },
        {
          "include": "#expression-operators"
        },
        {
          "include": "#invocation-function"
        },
        {
          "include": "#literal"
        },
        {
          "include": "#parenthesized-expression"
        },
        {
          "include": "#identifier"
        }
      ]
    },
    "intrusive": {
      "patterns": [
        {
          "include": "#preprocessor"
        },
        {
          "include": "#comment"
        }
      ]
    },
    "preprocessor": {
      "name": "meta.preprocessor.usp",
      "begin": "^\\s*(\\#)",
      "beginCaptures": {
        "1": {
          "name": "punctuation.separator.hash.usp"
        }
      },
      "end": "(?<=$)",
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "include": "#preprocessor-define-constant"
        },
        {
          "include": "#preprocessor-if-ifnot-defined"
        },
        {
          "include": "#preprocessor-endif"
        },
        {
          "include": "#preprocessor-category"
        },
        {
          "include": "#preprocessor-library"
        },
        {
          "include": "#preprocessor-include-path"
        },
        {
          "include": "#preprocessor-symbol-name"
        },
        {
          "include": "#preprocessor-hint"
        },
        {
          "include": "#preprocessor-help"
        },
        {
          "include": "#preprocessor-default-nonvolatile-volatile"
        },
        {
          "include": "#preprocessor-analog-digital-expand"
        },
        {
          "include": "#preprocessor-output-shift"
        },
        {
          "include": "#preprocessor-max-internal-buffer-size"
        },
        {
          "include": "#preprocessor-single"
        },
        {
          "include": "#preprocessor-begin-parameter-properties"
        },
        {
          "include": "#preprocessor-end-parameter-properties"
        }
      ]
    },
    "preprocessor-define-constant": {
      "begin": "(?ix)\\G  \\b(define_constant)\\b\\s*  #Directive\n  \\b([_[:alpha:]][\\#\\$\\_[:alnum:]]*)\\b\\s* #Constant Name\n",
      "end": "(?=$)",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.defineconstant.usp"
        },
        "2": {
          "name": "entity.name.variable.preprocessor.symbol.usp"
        }
      },
      "patterns": [
        {
          "match": "(\\G0[xX])([[:xdigit:]]{1,4})",
          "captures": {
            "1": {
              "name": "constant.numeric.other.prefix.hex.usp"
            },
            "2": {
              "name": "constant.numeric.hex.usp"
            }
          }
        },
        {
          "match": "(\\G[0-9]+)",
          "name": "constant.numeric.decimal.usp"
        },
        {
          "match": "(\\G\\'.\\')",
          "name": "constant.character.usp"
        },
        {
          "match": "(\\G\\\".*?\\\")",
          "name": "string.quoted.double.usp"
        }
      ]
    },
    "preprocessor-if-ifnot-defined": {
      "begin": "(?ix)\\G  \\b(if_defined)|(if_not_defined)\\b #Directive\n",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.ifdefined.usp"
        },
        "2": {
          "name": "keyword.preprocessor.ifnotdefined.usp"
        }
      },
      "end": "(?=$)",
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "match": "\\b([_[:alpha:]][\\#\\$\\_[:alnum:]]*)\\b",
          "name": "entity.name.variable.preprocessor.symbol.usp"
        }
      ]
    },
    "preprocessor-endif": {
      "match": "(?ix)\\G  \\b(endif)\\b #Directive\n",
      "captures": {
        "1": {
          "name": "keyword.preprocessor.endif.usp"
        }
      }
    },
    "preprocessor-category": {
      "begin": "(?ix)\\G  \\b(category)\\b\\s* #Directive\n",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.category.usp"
        }
      },
      "end": "(?=$)",
      "patterns": [
        {
          "match": "\\G\\\"[0-9]*?\\\"",
          "name": "constant.numeric.category.usp"
        }
      ]
    },
    "preprocessor-library": {
      "begin": "(?ix)\\G  \\b((?:(?:user_simplsharp|crestron_simplsharp|user|crestron)_)library)\\b\\s*\n",
      "beginCaptures": {
        "1": {
          "patterns": [
            {
              "match": "(?i)((?:user_simplsharp).*)",
              "name": "keyword.preprocessor.usersimplsharplibrary.usp"
            },
            {
              "match": "(?i)((?:crestron_simplsharp).*)",
              "name": "keyword.preprocessor.crestronsimplsharplibrary.usp"
            },
            {
              "match": "(?i)((?:user).*)",
              "name": "keyword.preprocessor.userlibrary.usp"
            },
            {
              "match": "(?i)((?:crestron).*)",
              "name": "keyword.preprocessor.crestronlibrary.usp"
            }
          ]
        }
      },
      "end": "(?=$)",
      "patterns": [
        {
          "match": "\\G(\\\".*?\\\")",
          "name": "string.quoted.double.usp"
        }
      ]
    },
    "preprocessor-include-path": {
      "begin": "(?ix)\\G  \\b(includepath)\\b\\s* #Directive\n",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.includepath.usp"
        }
      },
      "end": "(?=$)",
      "patterns": [
        {
          "match": "\\G(\\\".*?\\\")",
          "name": "string.quoted.double.usp"
        }
      ]
    },
    "preprocessor-symbol-name": {
      "begin": "(?ix)\\G  \\b(symbol_name)\\b\\s* #Directive\n",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.symbolname.usp"
        }
      },
      "end": "(?=$)",
      "patterns": [
        {
          "match": "\\G(\\\".*?\\\")",
          "name": "string.quoted.double.usp"
        }
      ]
    },
    "preprocessor-hint": {
      "begin": "(?ix)\\G  \\b(hint)\\b\\s* #Directive\n",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.hint.usp"
        }
      },
      "end": "(?=$)",
      "patterns": [
        {
          "match": "\\G(\\\".*?\\\")",
          "name": "string.quoted.double.usp"
        }
      ]
    },
    "preprocessor-help": {
      "begin": "(?ix)\\G  \\b(help)\\b\\s* #Directive\n",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.help.usp"
        }
      },
      "end": "(?=$)",
      "patterns": [
        {
          "match": "\\G(\\\".*?\\\")",
          "name": "string.quoted.double.usp"
        }
      ]
    },
    "preprocessor-default-nonvolatile-volatile": {
      "match": "(?ix)\\G  \\b(default_nonvolatile)|(default_volatile)\\b #Directive\n",
      "captures": {
        "1": {
          "name": "keyword.preprocessor.defaultnonvolatile.usp"
        },
        "2": {
          "name": "keyword.preprocessor.defaultvolatile.usp"
        }
      }
    },
    "preprocessor-analog-digital-expand": {
      "begin": "(?ix)\\G  \\b(?:(analog_serial_expand)|(digital_expand))\\b\\s* #Directive\n",
      "end": "(?=$)",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.analogserialexpand.usp"
        },
        "2": {
          "name": "keyword.preprocessor.digitalexpand.usp"
        }
      },
      "patterns": [
        {
          "match": "(?ix)\\G  ([a-z]+)$\n",
          "name": "keyword.control.option.usp"
        }
      ]
    },
    "preprocessor-output-shift": {
      "begin": "(?ix)\\G  \\b(output_shift)\\b\\s* #Directive\n",
      "end": "(?=$)",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.outputshift.usp"
        }
      },
      "patterns": [
        {
          "match": "\\G[0-9]+",
          "name": "constant.numeric.decimal.usp"
        }
      ]
    },
    "preprocessor-max-internal-buffer-size": {
      "begin": "(?ix)\\G  \\b(max_internal_buffer_size)\\b\\s* #Directive\n",
      "end": "(?=$)",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.outputshift.usp"
        }
      },
      "patterns": [
        {
          "match": "\\G[0-9]+",
          "name": "constant.numeric.decimal.usp"
        }
      ]
    },
    "preprocessor-single": {
      "begin": "(?ix)\\G  (?:\\b\n    (?:\n      (print_to_trace)|\n      (enable_dynamic)|\n      (enable_stack_checking)|\n      (large_stack)|\n      (enable_trace)|\n      (encoding_ascii)|\n      (encoding_inherit_from_parent)|\n      (encoding_inherit_from_program)|\n      (encoding_utf16)\n    )\\b)\n    \\s* #Directive\n",
      "end": "(?=$)",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.printtotrace.usp"
        },
        "2": {
          "name": "keyword.preprocessor.enabledynamic.usp"
        },
        "3": {
          "name": "keyword.preprocessor.enablestackchecking.usp"
        },
        "4": {
          "name": "keyword.preprocessor.largestack.usp"
        },
        "5": {
          "name": "keyword.preprocessor.enabletrace.usp"
        },
        "6": {
          "name": "keyword.preprocessor.encodingascii.usp"
        },
        "7": {
          "name": "keyword.preprocessor.encodinginheritfromparent.usp"
        },
        "8": {
          "name": "keyword.preprocessor.encodinginheritfromprogram.usp"
        },
        "9": {
          "name": "keyword.preprocessor.encodingutf16.usp"
        }
      }
    },
    "preprocessor-begin-parameter-properties": {
      "begin": "(?ix)\\G  \\b(begin_parameter_properties)\\b #Directive\n",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.beginparameterproperties.usp"
        }
      },
      "end": "(?=$)",
      "patterns": [
        {
          "include": "#identifier"
        },
        {
          "include": "#punctuation-comma"
        }
      ]
    },
    "preprocessor-end-parameter-properties": {
      "match": "(?ix)\\G  \\b(end_parameter_properties)\\b #directive\n",
      "captures": {
        "1": {
          "name": "keyword.preprocessor.endparameterproperties.usp"
        }
      }
    },
    "local-declarations": {
      "patterns": [
        {
          "include": "#local-variable-declaration"
        }
      ]
    },
    "local-variable-declaration": {
      "begin": "(?ix) (?:  (?:(dynamic|volatile|nonvolatile|ascii|utf16|inherit)?\\s+)? # declaration modifier\n  (?<type_name>\n    (?:\n      (?:\n        (?<identifier>[_[:alpha:]][\\#\\$\\_[:alnum:]]*)\n        (?:\\s*\\.\\s*\\g<identifier>)* | # Are there any more names being dotted into?\n      )\n    )\n  )\n)\\s+ (  (\\g<identifier>)\\s*\n  (?:\\s*                 # array suffix?\n      (?:(\\[)\\d*(\\])\\s*)\n      (?:(\\[)\\d*(\\])\\s*)?\n  )?\n) (?=,|;|=|\\))\n",
      "beginCaptures": {
        "1": {
          "name": "storage.modifier.$1.usp"
        },
        "2": {
          "patterns": [
            {
              "include": "#type"
            }
          ]
        },
        "4": {
          "patterns": [
            {
              "include": "#simple-designation-pattern"
            }
          ]
        }
      },
      "end": "(?=[;)}])",
      "patterns": [
        {
          "include": "#simple-designation-pattern"
        },
        {
          "include": "#punctuation-comma"
        },
        {
          "include": "#comment"
        },
        {
          "include": "#variable-initializer"
        }
      ]
    },
    "invocation-function": {
      "begin": "(?ix)\n(?:\n  (\\.)\\s*|                                        # preceding dot?\n)?\n(@?[_[:alpha:]][\\#\\$\\_[:alnum:]]*)\\s*                  # method name\n(?=\\()                                            # open paren of argument list",
      "beginCaptures": {
        "1": {
          "name": "punctuation.accessor.usp"
        },
        "2": {
          "name": "entity.name.function.usp"
        }
      },
      "end": "(?<=\\))",
      "patterns": [
        {
          "include": "#argument-list"
        }
      ]
    },
    "parenthesized-parameter-list": {
      "begin": "(\\()",
      "beginCaptures": {
        "0": {
          "name": "punctuation.parenthesis.open.usp"
        }
      },
      "end": "(\\))",
      "endCaptures": {
        "0": {
          "name": "punctuation.parenthesis.close.usp"
        }
      },
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "include": "#attribute-section"
        },
        {
          "include": "#parameter"
        },
        {
          "include": "#punctuation-comma"
        }
      ]
    },
    "parameter": {
      "match": "(?ix)\n(?:(?:\\b(ByRef|ByVal|ReadOnlyByRef)\\b)\\s+)?\n(?<type_name>\n (?:\n    (?:\n      (?<identifier>[_[:alpha:]][\\#\\$\\_[:alnum:]]*)\n      (?:\\s*\\.\\s*\\g<identifier>)* | # Are there any more names being dotted into?\n    )\n    (?:\\s* # array suffix?\n      \\[\n        (?:\\s*,\\s*)* # commata for multi-dimensional arrays\n      \\]\n      \\s*\n    )*\n  )\n)\\s+\n(\\g<identifier>)",
      "captures": {
        "1": {
          "name": "storage.modifier.$1.usp"
        },
        "2": {
          "patterns": [
            {
              "include": "#type"
            }
          ]
        },
        "4": {
          "name": "entity.name.variable.parameter.usp"
        }
      }
    },
    "bracketed-argument-list": {
      "begin": "\\[",
      "beginCaptures": {
        "0": {
          "name": "punctuation.squarebracket.open.usp"
        }
      },
      "end": "\\]",
      "endCaptures": {
        "0": {
          "name": "punctuation.squarebracket.close.usp"
        }
      },
      "patterns": [
        {
          "include": "#argument"
        },
        {
          "include": "#punctuation-comma"
        }
      ]
    },
    "argument-list": {
      "begin": "\\(",
      "beginCaptures": {
        "0": {
          "name": "punctuation.parenthesis.open.usp"
        }
      },
      "end": "\\)",
      "endCaptures": {
        "0": {
          "name": "punctuation.parenthesis.close.usp"
        }
      },
      "patterns": [
        {
          "include": "#argument"
        },
        {
          "include": "#punctuation-comma"
        }
      ]
    },
    "argument": {
      "patterns": [
        {
          "name": "storage.modifier.$1.usp",
          "match": "(?i)\\b(ByRef|ByVal|ReadOnlyByRef)\\\\b\""
        },
        {
          "include": "#expression"
        }
      ]
    },
    "type": {
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "include": "#ref-modifier"
        },
        {
          "include": "#type-builtin"
        },
        {
          "include": "#type-name"
        }
      ]
    },
    "type-builtin": {
      "match": "(?ix)\\b(integer|long_integer|signed_integer|signed_long_integer|string|structure)\\b",
      "comment": "Crestron Built In Types",
      "name": "keyword.type.$1.usp"
    },
    "type-name": {
      "patterns": [
        {
          "match": "(?(@?[_[:alpha:]][\\_\\#\\_\\$[:alnum:]]*)\\s*(\\.))",
          "captures": {
            "1": {
              "name": "entity.name.type.usp"
            },
            "2": {
              "name": "punctuation.accessor.usp"
            }
          }
        },
        {
          "match": "(?:(\\.)\\s*(@?[_[:alpha:]][\\_\\#\\_\\$_[:alnum:]]*))",
          "captures": {
            "1": {
              "name": "punctuation.accessor.usp"
            },
            "2": {
              "name": "entity.name.type.usp"
            }
          }
        },
        {
          "name": "entity.name.type.usp",
          "match": "(@?[_[:alpha:]][\\_\\#\\_\\$_[:alnum:]]*)"
        }
      ]
    },
    "designation-pattern": {
      "patterns": [
        {
          "include": "#intrusive"
        },
        {
          "begin": "\\(",
          "beginCaptures": {
            "0": {
              "name": "punctuation.parenthesis.open.usp"
            }
          },
          "end": "\\)",
          "endCaptures": {
            "0": {
              "name": "punctuation.parenthesis.close.usp"
            }
          },
          "patterns": [
            {
              "include": "#punctuation-comma"
            },
            {
              "include": "#designation-pattern"
            }
          ]
        },
        {
          "include": "#simple-designation-pattern"
        }
      ]
    },
    "simple-designation-pattern": {
      "patterns": [
        {
          "match": "(?x) (?:  ([_[:alpha:]][\\#\\$\\_[:alnum:]]*) #Name\n  (?:\\s*                   # array suffix?\n    (?:(\\[)\\d*(\\])\\s*)\n    (?:(\\[)\\d*(\\])\\s*)?\n  )?\n)\n",
          "captures": {
            "1": {
              "name": "entity.name.variable.local.usp"
            },
            "2": {
              "name": "punctuation.squarebracket.open.usp"
            },
            "3": {
              "name": "punctuation.squarebracket.close.usp"
            },
            "4": {
              "name": "punctuation.squarebracket.open.usp"
            },
            "5": {
              "name": "punctuation.squarebracket.close.usp"
            }
          }
        }
      ]
    },
    "type-array-suffix": {
      "begin": "\\[",
      "beginCaptures": {
        "0": {
          "name": "punctuation.squarebracket.open.usp"
        }
      },
      "end": "\\]",
      "endCaptures": {
        "0": {
          "name": "punctuation.squarebracket.close.usp"
        }
      },
      "patterns": [
        {
          "include": "#intrusive"
        },
        {
          "include": "#punctuation-comma"
        }
      ]
    },
    "assignment-expression": {
      "begin": "\\=(?!=|>)\"",
      "beginCaptures": {
        "0": {
          "patterns": [
            {
              "include": "#assignment-operators"
            }
          ]
        }
      },
      "end": "(?=[,\\)\\];}])",
      "patterns": [
        {
          "include": "#expression"
        }
      ]
    },
    "parenthesized-expression": {
      "begin": "\\(",
      "beginCaptures": {
        "0": {
          "name": "punctuation.parenthesis.open.usp"
        }
      },
      "end": "\\)",
      "endCaptures": {
        "0": {
          "name": "punctuation.parenthesis.close.usp"
        }
      },
      "patterns": [
        {
          "include": "#expression"
        }
      ]
    },
    "string-literal": {
      "name": "string.quoted.double.usp",
      "begin": "\\\"",
      "beginCaptures": {
        "0": {
          "name": "punctuation.definition.string.begin.usp"
        }
      },
      "end": "(\")|((?:[^\\\\\\n])$)",
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.string.end.usp"
        },
        "2": {
          "name": "invalid.illegal.newline.usp"
        }
      },
      "patterns": [
        {
          "include": "#string-character-escape"
        }
      ]
    },
    "expression-operator-expression": {
      "begin": "(\\()",
      "beginCaptures": {
        "1": {
          "name": "punctuation.parenthesis.open.usp"
        }
      },
      "end": "\\)",
      "endCaptures": {
        "0": {
          "name": "punctuation.parenthesis.close.usp"
        }
      },
      "patterns": [
        {
          "include": "#expression"
        }
      ]
    },
    "assignment-operators": {
      "patterns": [
        {
          "name": "keyword.operator.assignment.usp",
          "match": "\\="
        }
      ]
    },
    "expression-operators": {
      "patterns": [
        {
          "name": "keyword.operator.bitwise.shift.usp",
          "match": "(?i)<<|>>"
        },
        {
          "name": "keyword.operator.bitwise.rotate.usp",
          "match": "{{|}}"
        },
        {
          "name": "keyword.operator.comparison.usp",
          "match": "=|<>"
        },
        {
          "name": "keyword.operator.relational.usp",
          "match": "<=|>=|<|>|S<=|S>=|S<|S>"
        },
        {
          "name": "keyword.operator.logical.usp",
          "match": "\\!|&&|\\|\\|"
        },
        {
          "name": "keyword.operator.bitwise.usp",
          "match": "(?i)\\&|not|\\^|\\|"
        },
        {
          "name": "keyword.operator.arithmetic.usp",
          "match": "(?i)\\+|-(?!>)|\\*|\\/|S\\/|%|mod|umod"
        }
      ]
    },
    "string-character-escape": {
      "name": "constant.character.escape.usp",
      "match": "(?x)  (\\\\ #escape initializer character\n    (?:\n      [abfnrt\\'\\\"\\\\]| #Static Specification String #AudibleAlert, Backspace, Formfeed, CRLF, CR, Tab, SingleQuote, DoubleQuote, Backslash\n      x[0-9A-Fa-f]{2}| #Hexadecimal Constant\n    )|\n    %(?:[0-9]?[0-9])? #[[pad]width]\n      (?:\n        d| #Signed Analog_Input, Analog_Output or Integer as decimal\n        s| #Buffer_Input, String_Input or String\n        u| #Unsigned Analog_Input, Analog_Output or integer\n        ld| #Long_Integer as decimal\n        lu| #Long_Unsigned_Integer as decimal\n        %   #Prints % \n      )| #Print Formatters %[[pad]width]specifier\n    %(?:\n        x| #Analog_Input, Analog_Output or Integer as lowercase hexadecimal\n        X| #Analog_Input, Analog_Output or Integer as uppercase hexadecimal\n    )\n  )\n"
    },
    "numbers": {
      "match": "\\b((0x[a-fA-F0-9]{1,8})|([0-9]+))\\b",
      "name": "constant.numeric.usp"
    },
    "literal": {
      "patterns": [
        {
          "include": "#numeric-literal"
        },
        {
          "include": "#char-literal"
        },
        {
          "include": "#string-literal"
        },
        {
          "include": "#expression-operators"
        }
      ]
    },
    "numeric-literal": {
      "match": "(?x)  (?<!\\w)\\.?\\d\n  (?:\n    (?:[0-9a-zA-Z_]|_)| #capture any digit or letter or underscore (anything that resembles a number)\n    (?<=[eE])[+-]| # even if it looks scientific\n    \\.\\d #or floating point\n  )*\n",
      "captures": {
        "0": {
          "patterns": [
            {
              "begin": "(?=.)",
              "end": "$",
              "patterns": [
                {
                  "match": "(?x)  (0[xX]) #ensure it starts with a 0x or 0X\n  ([0-9a-fA-F](?:[0-9a-fA-F])*)$ #capture rest of hex digits\n",
                  "captures": {
                    "1": {
                      "name": "constant.numeric.other.preffix.hex.cs"
                    },
                    "2": {
                      "name": "constant.numeric.hex.cs"
                    }
                  }
                },
                {
                  "match": "(?x)  (?=[0-9])(?!0[xX]) #ensure it starts with a digit, but not wit a 0x or 0X \n  ([0-9](?:[0-9])*)$ #capture rest of decimal digits\n",
                  "captures": {
                    "1": {
                      "name": "constant.numeric.decimal.cs"
                    }
                  }
                },
                {
                  "match": "(?:(?:[0-9a-zA-Z_]|_)|(?<=[eE])[+-]|\\.\\d)+",
                  "name": "invalid.illegal.constant.numeric.cs"
                }
              ]
            }
          ]
        }
      }
    },
    "char-literal": {
      "name": "string.quoted.single.cs",
      "begin": "\\'",
      "beginCaptures": {
        "0": {
          "name": "punctuation.definition.char.begin.cs"
        }
      },
      "end": "(\\')|((?:[^\\n])$)",
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.char.end.cs"
        },
        "2": {
          "name": "invalid.illegal.newline.cs"
        }
      },
      "patterns": [
        {
          "match": "([0-9a-zA-Z]{2,})",
          "name": "invalid.illegal.char.cs"
        }
      ]
    },
    "punctuation-comma": {
      "match": "\\,",
      "name": "punctuation.separator.comma.usp"
    },
    "punctuation-semicolon": {
      "match": "\\;",
      "name": "punctuation.terminator.statement.usp"
    },
    "punctuation-accessor": {
      "match": "\\.",
      "name": "punctuation.accessor.usp"
    },
    "comment": {
      "patterns": [
        {
          "name": "comment.line.double-slash.usp",
          "begin": "(^\\s+)?(\\/\\/).*$",
          "while": "^(\\s*)(\\/\\/).*$",
          "captures": {
            "1": {
              "name": "punctuation.whitespace.comment.leading.usp"
            },
            "2": {
              "name": "punctuation.definition.comment.usp"
            }
          }
        },
        {
          "name": "comment.block.usp",
          "begin": "\\/\\*",
          "end": "\\*\\/",
          "captures": {
            "0": {
              "name": "punctuation.definition.comment.usp"
            }
          }
        },
        {
          "contentName": "comment.block.documentation.usp",
          "begin": "(?i)(?:(help_begin)|(begin_prop_full_description)|(begin_prop_notes))",
          "beginCaptures": {
            "1": {
              "name": "keyword.preprocessor.helpbegin.usp"
            },
            "2": {
              "name": "keyword.preprocessor.beginpropfulldescription.usp"
            },
            "3": {
              "name": "keyword.preprocessor.beginpropnotes.usp"
            }
          },
          "end": "(?i)(\\#)(?:(help_end)|(end_prop_full_description)|(end_prop_notes))$",
          "endCaptures": {
            "1": {
              "name": "punctuation.separator.hash.usp"
            },
            "2": {
              "name": "keyword.preprocessor.helpend.usp"
            },
            "3": {
              "name": "keyword.preprocessor.endpropfulldescription.usp"
            },
            "4": {
              "name": "keyword.preprocessor.endpropnotes.usp"
            }
          }
        }
      ]
    }
  }
}