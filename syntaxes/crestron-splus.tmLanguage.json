{
  "scopeName": "source.splus",
  "fileTypes": [
    "usp",
    "usl"
  ],
  "name": "Crestron",
  "patterns": [
    {
      "include": "#comment"
    },
    {
      "include": "#preprocessor"
    },
    {
      "include": "#statements"
    },
    {
      "include": "#expressions"
    },
    {
      "include": "#operands"
    },
    {
      "include": "#declarations"
    },
    {
      "include": "#punctuation"
    }
  ],
  "repository": {
    "statements": {
      "patterns": [
        {
          "include": "#looping-statement"
        },
        {
          "include": "#wait-statement"
        },
        {
          "include": "#branching-and-decision-statement"
        },
        {
          "include": "#exception-handling-statement"
        },
        {
          "include": "#variable-assignments-statement"
        },
        {
          "include": "#local-variable-name-declarations-statement"
        },
        {
          "include": "#built-in-function-calls-statement"
        },
        {
          "include": "#user-defined-function-calls-statement"
        },
        {
          "include": "#SimplSharp-method-calls-statement"
        }
      ]
    },
    "looping-statement": {
      "patterns": []
    },
    "wait-statement": {
      "patterns": []
    },
    "branching-and-decision-statement": {
      "patterns": []
    },
    "exception-handling-statement": {
      "patterns": []
    },
    "variable-assignments-statement": {
      "patterns": []
    },
    "local-variable-name-declarations-statement": {
      "patterns": []
    },
    "built-in-function-calls-statement": {
      "patterns": []
    },
    "user-defined-function-calls-statement": {
      "patterns": []
    },
    "SimplSharp-method-calls-statement": {
      "patterns": []
    },
    "expressions": {
      "patterns": [
        {
          "include": "#relational-expression"
        },
        {
          "include": "#parenthesized-expression"
        },
        {
          "include": "#assignment-expression"
        },
        {
          "include": "#arithmetic-expression"
        },
        {
          "include": "#literal-expression"
        },
        {
          "include": "#integer-expression"
        },
        {
          "include": "#string-expression"
        },
        {
          "include": "#member-access-expression"
        },
        {
          "include": "#unary-expression"
        },
        {
          "include": "#bitwise-expression"
        }
      ]
    },
    "relational-expression": {
      "patterns": []
    },
    "parenthesized-expression": {
      "patterns": []
    },
    "assignment-expression": {
      "patterns": []
    },
    "arithmetic-expression": {
      "patterns": []
    },
    "literal-expression": {
      "patterns": []
    },
    "integer-expression": {
      "patterns": []
    },
    "string-expression": {
      "patterns": []
    },
    "member-access-expression": {
      "patterns": []
    },
    "unary-expression": {
      "patterns": []
    },
    "bitwise-expression": {
      "patterns": []
    },
    "operands": {
      "patterns": [
        {
          "include": "#user-defined-functions"
        },
        {
          "include": "#built-in-functions"
        },
        {
          "include": "#built-in-constants"
        },
        {
          "include": "#user-constants"
        },
        {
          "include": "#variables"
        },
        {
          "include": "#built-in-variables"
        },
        {
          "include": "#literals"
        }
      ]
    },
    "user-defined-functions": {
      "patterns": []
    },
    "built-in-functions": {
      "patterns": []
    },
    "built-in-constants": {
      "patterns": []
    },
    "user-constants": {
      "patterns": []
    },
    "variables": {
      "patterns": []
    },
    "built-in-variables": {
      "patterns": []
    },
    "literals": {
      "patterns": [
        {
          "include": "#numeric-literal"
        },
        {
          "include": "#char-literal"
        },
        {
          "include": "#string-literal"
        }
      ]
    },
    "invocation-function": {
      "begin": "(?ix)\n(?:\n  (\\.)\\s*|                                        # preceding dot?\n)?\n(@?[_[:alpha:]][\\#\\$\\_[:alnum:]]*)\\s*                  # method name\n(?=\\()                                            # open paren of argument list",
      "beginCaptures": {
        "1": {
          "name": "punctuation.accessor.usp"
        },
        "2": {
          "name": "entity.name.function.usp"
        }
      },
      "end": "(?<=\\))",
      "patterns": [
        {
          "include": "#argument-list"
        }
      ]
    },
    "numeric-literal": {
      "match": "(?x)\n  (?<!\\w)\\.?\\d #ensure it starts with a digit or period and not a word character\n  (?:\n    (?:[0-9a-zA-Z_%]|_)| #capture any digit or letter or underscore (anything that resembles a number)\n    (?<=[eE])[+-]| # even if it looks scientific\n    \\.\\d #or floating point\n  )*",
      "captures": {
        "0": {
          "patterns": [
            {
              "begin": "(?=.)",
              "end": "$",
              "patterns": [
                {
                  "match": "(?x)\n  (0[xX]) #ensure it starts with a 0x or 0X\n  ([0-9a-fA-F](?:[0-9a-fA-F])*)$ #capture rest of hex digits",
                  "captures": {
                    "1": {
                      "name": "constant.numeric.other.prefix.hex.usp"
                    },
                    "2": {
                      "name": "constant.numeric.hex.usp"
                    }
                  }
                },
                {
                  "match": "(?x)\n  (?=[0-9])(?!0[xX]) #ensure it starts with a digit, but not wit a 0x or 0X \n  ([0-9d](?:[0-9d])*)$ #capture rest of decimal digits and d (for parameter properties decimal value)",
                  "captures": {
                    "1": {
                      "name": "constant.numeric.decimal.usp"
                    }
                  }
                },
                {
                  "match": "(?ix)\n  (?=[0-9a-f])(?!0[xX]) #ensure it starts with a hex digit, but not wit a 0x or 0X \n  ([0-9a-fh](?:[0-9a-fh])*)$ #capture rest of hex digits and h (for parameter properties decimal value)hex value)",
                  "captures": {
                    "1": {
                      "name": "constant.numeric.hex.usp"
                    }
                  }
                },
                {
                  "match": "(?x)\n  (?=[0-9])(?!0[xX]) #ensure it starts with a digit, but not wit a 0x or 0X \n  ([0-9%](?:[0-9%])*)$ #capture rest of decimal digits and % (for parameter properties percentage value)",
                  "captures": {
                    "1": {
                      "name": "constant.numeric.percentage.usp"
                    }
                  }
                },
                {
                  "match": "(?x)\n  (?=[0-9])(?!0[xX]) #ensure it starts with a digit, but not wit a 0x or 0X \n  ([0-9s](?:[0-9s])*)$ #capture rest of decimal digits and s (for parameter properties seconds value)",
                  "captures": {
                    "1": {
                      "name": "constant.numeric.seconds.usp"
                    }
                  }
                },
                {
                  "match": "(?x)\n  (?=[0-9])(?!0[xX]) #ensure it starts with a digit, but not wit a 0x or 0X \n  ([0-9t](?:[0-9t])*)$ #capture rest of decimal digits and t (for parameter properties ticks value)",
                  "captures": {
                    "1": {
                      "name": "constant.numeric.ticks.usp"
                    }
                  }
                },
                {
                  "match": "(?:(?:[0-9a-zA-Z_]|_)|(?<=[eE])[+-]|\\.\\d)+",
                  "name": "invalid.illegal.constant.numeric.usp"
                }
              ]
            }
          ]
        }
      }
    },
    "char-literal": {
      "name": "string.quoted.single.usp",
      "begin": "\\'",
      "beginCaptures": {
        "0": {
          "name": "punctuation.definition.char.begin.usp"
        }
      },
      "end": "(\\')|((?:[^\\n])$)",
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.char.end.usp"
        },
        "2": {
          "name": "invalid.illegal.newline.usp"
        }
      },
      "patterns": [
        {
          "match": "([0-9a-zA-Z]{2,})",
          "name": "invalid.illegal.char.usp"
        }
      ]
    },
    "string-literal": {
      "name": "string.quoted.double.usp",
      "begin": "\\\"",
      "beginCaptures": {
        "0": {
          "name": "punctuation.definition.string.begin.usp"
        }
      },
      "end": "(\")|((?:[^\\n])$)",
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.string.end.usp"
        },
        "2": {
          "name": "invalid.illegal.newline.usp"
        }
      },
      "patterns": [
        {
          "include": "#string-character-escape"
        }
      ]
    },
    "string-character-escape": {
      "match": "(?x)\n  (\\%   #escape initializer character either % or \\\n    (?:\n      (?:[0-9a-zA-Z]|\\%)? #grab any digit or letter or % character for next character zero or 1 times\n      (?:[0-9a-zA-Z])*    #grab the rest of the digits or letters\n    )\n  ) |  #or\n  (\\\\(?:[a-zA-Z\\\\])(?:(?:[0-9a-fA-F]){2})?) #grab any one letter or dual hex number after a backslash",
      "captures": {
        "0": {
          "patterns": [
            {
              "begin": "(?=.)",
              "end": "$",
              "patterns": [
                {
                  "match": "(?x)\n  (%%) |  # Prints % or\n  (%\n    (?:\n      (?:[0-9]?[0-9])? #[[pad]width]\n      (?:\n        d|  #Signed Analog_Input, Analog_Output or Integer as decimal\n        s|  #Buffer_Input, String_Input or String\n        u|  #Unsigned Analog_Input, Analog_Output or integer\n        ld| #Long_Integer as decimal\n        lu| #Long_Unsigned_Integer as decimal\n        x|  #Analog_Input, Analog_Output or Integer as lowercase hexadecimal\n        X|  #Analog_Input, Analog_Output or Integer as uppercase hexadecimal\n        c|  #Printable ASCII character\n      ){1}\n    ) #Print Formatters %[[pad]width]specifier\n  )",
                  "name": "constant.character.escape.usp"
                },
                {
                  "match": "(?x)\n   (\\\\\n     (?:\n       a|  #Alert (Beep)\n       b|  #Backspace\n       f|  #Form Feed\n       n|  #Newline\n       r|  #Carriage Return\n       t|  #Horizontal Tab\n       v|  #Vertical Tab\n       \\\\| slash\n     )\n   ) |\n   (\\\\\n     (?:\n       [xX](?:[0-9a-fA-F]){2} |  #Hexadecimal character code\n     )\n   )",
                  "name": "constant.character.escape.usp"
                },
                {
                  "match": ".*",
                  "name": "invalid.illegal.character.escape.usp"
                }
              ]
            }
          ]
        }
      }
    },
    "declarations": {
      "patterns": [
        {
          "include": "#input-declaration"
        },
        {
          "include": "#output-declaration"
        },
        {
          "include": "#parameter-declaration"
        },
        {
          "include": "#structure-declaration"
        },
        {
          "include": "#function-declaration"
        },
        {
          "include": "#event-declaration"
        },
        {
          "include": "#callback-declaration"
        },
        {
          "include": "#namespace-declaration"
        },
        {
          "include": "#variable-declaration"
        }
      ]
    },
    "input-declaration": {
      "name": "meta.declaration.input.usp",
      "begin": "(?ix)\n  (?=(?:digital_input|analog_input|buffer_input|string_input)) #start pattern at the beginning of the input keyword without grabbing any characters",
      "end": "(?ix)\n  (;)|(?=\\{)   #stop pattern before the closing curly brace or at semicolon",
      "endCaptures": {
        "1": {
          "name": "punctuation.terminator.input.usp"
        }
      },
      "patterns": [
        {
          "match": "(?i)\\b(digital_input|analog_input|buffer_input|string_input)\\b",
          "name": "keyword.declaration.input.usp"
        },
        {
          "match": "([\\_[:alpha:]][\\_\\#\\_\\$[:alnum:]]*)",
          "name": "entity.name.variable.input.usp"
        },
        {
          "include": "#declaration-skip"
        },
        {
          "include": "#comment"
        },
        {
          "include": "#punctuation-comma"
        },
        {
          "include": "#type-array-suffix"
        }
      ]
    },
    "output-declaration": {
      "name": "meta.declaration.output.usp",
      "begin": "(?ix)\n  (?=(?:digital_output|analog_output|buffer_output|string_output)) #start pattern at the beginning of the input keyword without grabbing any characters",
      "end": "(?ix)\n  (;)|(?=\\{)   #stop pattern before the closing curly brace or at semicolon",
      "endCaptures": {
        "1": {
          "name": "punctuation.terminator.output.usp"
        }
      },
      "patterns": [
        {
          "match": "(?i)\\b(digital_output|analog_output|buffer_output|string_output)\\b",
          "name": "keyword.declaration.output.usp"
        },
        {
          "match": "([\\_[:alpha:]][\\_\\#\\_\\$[:alnum:]]*)",
          "name": "entity.name.variable.output.usp"
        },
        {
          "include": "#declaration-skip"
        },
        {
          "include": "#comment"
        },
        {
          "include": "#punctuation-comma"
        },
        {
          "include": "#type-array-suffix"
        }
      ]
    },
    "parameter-declaration": {
      "name": "meta.declaration.parameter.usp",
      "begin": "(?ix)\n  (?=(?:integer_parameter|string_parameter|long_integer_parameter|signed_integer_parameter|signed_long_integer_parameter)) #start pattern at the beginning of the input keyword without grabbing any characters",
      "end": "(?ix)\n  (;)|(?=\\{)   #stop pattern before the closing curly brace or at semicolon",
      "endCaptures": {
        "1": {
          "name": "punctuation.terminator.parameter.usp"
        }
      },
      "patterns": [
        {
          "match": "(?i)\\b(integer_parameter|string_parameter|long_integer_parameter|signed_integer_parameter|signed_long_integer_parameter)\\b",
          "name": "keyword.declaration.parameter.usp"
        },
        {
          "match": "([\\_[:alpha:]][\\_\\#\\_\\$[:alnum:]]*)",
          "name": "entity.name.variable.parameter.usp"
        },
        {
          "include": "#declaration-skip"
        },
        {
          "include": "#comment"
        },
        {
          "include": "#punctuation-comma"
        },
        {
          "include": "#type-array-suffix"
        }
      ]
    },
    "variable-declaration": {
      "begin": "(?x)\n  (?=\n    ^        #start pattern at the beginning of a line\n    [^\\(]*   #grab everything that doesn't have ann opening parenthesis\n    \\s*      #across multiple lines\n    (?<!});  #and end on a semicolon that doesn't have a curly bracket behind it\n  )          #without grabbing any characters",
      "end": "(?x)\n  (?<=;) #stop pattern after the semicolon without grabbing any characters",
      "patterns": [
        {
          "begin": "(?ix)\n  (?:\\s*)\n  (dynamic|volatile|nonvolatile|ascii|utf16|inherit)?\\s*  #Possibly grab modifier\n  (?:\n    (integer|string|long_integer|signed_integer|signed_long_integer|simplsharpstring|delegateproperty)| #grab the variable type or\n    (cevent|cmutex)| #or built in class\n    ([_[:alpha:]][\\#\\$\\_[:alnum:]]*)\\s* #grab the variable name\n  )",
          "beginCaptures": {
            "1": {
              "name": "keyword.modifier.variable.usp"
            },
            "2": {
              "name": "keyword.declaration.variable.usp"
            },
            "3": {
              "name": "keyword.support.class.usp"
            },
            "4": {
              "name": "entity.name.type.usp"
            }
          },
          "end": "(?ix)\n  (\\;)  #stop pattern before the closing curly brace or before semicolon without grabbing any characters",
          "endCaptures": {
            "1": {
              "name": "punctuation.terminator.variable.usp"
            }
          },
          "name": "meta.declaration.variable.usp",
          "patterns": [
            {
              "match": "([\\_[:alpha:]][\\_\\#\\_\\$[:alnum:]]*)",
              "name": "entity.name.variable.usp"
            },
            {
              "include": "#type-array-suffix"
            },
            {
              "include": "#comment"
            },
            {
              "include": "#punctuation-comma"
            }
          ]
        }
      ]
    },
    "structure-declaration": {
      "begin": "(?ix)\n  (?=\\bstructure\\b) #start pattern at the beginning of the word structure without grabbing any characters",
      "end": "(?ix)\n  (?<=};)   #stop pattern after the closing curly brace semicolon pair without grabbing any characters",
      "patterns": [
        {
          "begin": "(?ix)\n  \\b(structure)\\b\\s+\n  ([_[:alpha:]][\\#\\$\\_[:alnum:]]*)",
          "beginCaptures": {
            "1": {
              "name": "keyword.declaration.structure.usp"
            },
            "2": {
              "name": "entity.name.type.structure.usp"
            }
          },
          "end": "(?ix)\n  (?=\\{)|(?=;) #stop pattern after the opening curly brace or before semicolon without grabbing any characters",
          "name": "meta.declaration.structure.usp",
          "patterns": [
            {
              "include": "#comment"
            }
          ]
        },
        {
          "begin": "(\\{)",
          "beginCaptures": {
            "1": {
              "name": "punctuation.curlybrace.open.usp"
            }
          },
          "end": "(\\})\\s*(;)",
          "endCaptures": {
            "1": {
              "name": "punctuation.curlybrace.close.usp"
            },
            "2": {
              "name": "punctuation.terminator.structure.usp"
            }
          },
          "name": "meta.structure.contents",
          "patterns": [
            {
              "include": "#structure-members"
            },
            {
              "include": "#preprocessor"
            },
            {
              "include": "#comment"
            }
          ]
        }
      ]
    },
    "function-declaration": {
      "begin": "(?ix)\n  (?=(?:function|integer_function|string_function|long_integer_function|signed_integer_function|signed_long_integer_function|simplsharpstring)) #start pattern at the beginning of the function keyword without grabbing any characters",
      "end": "(?ix)\n  (?<=})   #stop pattern after the closing curly brace without grabbing any characters",
      "patterns": [
        {
          "begin": "(?ix)\n  (function|integer_function|string_function|long_integer_function|signed_integer_function|signed_long_integer_function|simplsharpstring)\\b\\s+\n  ([_[:alpha:]][\\#\\$\\_[:alnum:]]*)",
          "beginCaptures": {
            "1": {
              "name": "keyword.declaration.function.usp"
            },
            "2": {
              "name": "entity.name.variable.function.usp"
            }
          },
          "end": "(?ix)\n  (?=\\{) #stop pattern after the opening curly brace without grabbing any characters",
          "name": "meta.declaration.function.usp",
          "patterns": [
            {
              "include": "#comment"
            },
            {
              "include": "#parenthesized-parameter-list"
            }
          ]
        },
        {
          "begin": "(\\{)",
          "beginCaptures": {
            "1": {
              "name": "punctuation.curlybrace.open.usp"
            }
          },
          "end": "(\\})",
          "endCaptures": {
            "1": {
              "name": "punctuation.curlybrace.close.usp"
            }
          },
          "name": "meta.function.contents",
          "patterns": [
            {
              "include": "#statements"
            },
            {
              "include": "#variable-declaration"
            },
            {
              "include": "statement"
            },
            {
              "include": "#preprocessor"
            },
            {
              "include": "#comment"
            }
          ]
        }
      ]
    },
    "event-declaration": {
      "begin": "(?ix)\n  (?=\n    (\\bthreadsafe\\b\\s+)? #Possibly grab threadsafe\n    (?:push|event|change|release|socketconnect|socketdisconnect|socketreceive|socketstatus|eventhandler)\n  ) #start pattern at the beginning of the function keyword without grabbing any characters",
      "end": "(?ix)\n  (?<=})   #stop pattern after the closing curly brace without grabbing any characters",
      "patterns": [
        {
          "begin": "(?ix)\n  (\\bthreadsafe\\b\\s+)?\n  (push|event|change|release|socketconnect|socketdisconnect|socketreceive|socketstatus|eventhandler)\\b\\s+",
          "beginCaptures": {
            "1": {
              "name": "keyword.modifier.event.usp"
            },
            "2": {
              "name": "keyword.declaration.event.usp"
            },
            "3": {
              "name": "entity.name.variable.event.usp"
            }
          },
          "end": "(?ix)\n  (?=\\{) #stop pattern after the opening curly brace without grabbing any characters",
          "name": "meta.declaration.event.usp",
          "patterns": [
            {
              "match": "([\\_[:alpha:]][\\_\\#\\_\\$[:alnum:]]*)",
              "name": "entity.name.variable.event.usp"
            },
            {
              "include": "#punctuation-comma"
            },
            {
              "include": "#comment"
            },
            {
              "include": "#parenthesized-parameter-list"
            }
          ]
        },
        {
          "begin": "(\\{)",
          "beginCaptures": {
            "1": {
              "name": "punctuation.curlybrace.open.usp"
            }
          },
          "end": "(\\})",
          "endCaptures": {
            "1": {
              "name": "punctuation.curlybrace.close.usp"
            }
          },
          "name": "meta.event.contents",
          "patterns": [
            {
              "include": "#statements"
            },
            {
              "include": "#variable-declaration"
            },
            {
              "include": "statement"
            },
            {
              "include": "#preprocessor"
            },
            {
              "include": "#comment"
            }
          ]
        }
      ]
    },
    "callback-declaration": {
      "begin": "(?ix)\n  (?=\n    (\\bcallback\\b\\s+)? #test for callback\n    (?:function|integer_function|string_function|long_integer_function|signed_integer_function|signed_long_integer_function|simplsharpstring)\n  ) #start pattern at the beginning of the callback function keyword without grabbing any characters",
      "end": "(?ix)\n  (?<=})   #stop pattern after the closing curly brace without grabbing any characters",
      "patterns": [
        {
          "begin": "(?ix)\n  (\\bcallback\\b\\s+)? #grab the callback keyword\n  (function|integer_function|string_function|long_integer_function|signed_integer_function|signed_long_integer_function|simplsharpstring)\\b\\s+\n  ([_[:alpha:]][\\#\\$\\_[:alnum:]]*)",
          "beginCaptures": {
            "1": {
              "name": "keyword.declaration.callback.usp"
            },
            "2": {
              "name": "keyword.declaration.function.usp"
            },
            "3": {
              "name": "entity.name.variable.function.usp"
            }
          },
          "end": "(?ix)\n  (?=\\{) #stop pattern after the opening curly brace without grabbing any characters",
          "name": "meta.declaration.function.usp",
          "patterns": [
            {
              "include": "#comment"
            },
            {
              "include": "#parenthesized-parameter-list"
            }
          ]
        },
        {
          "begin": "(\\{)",
          "beginCaptures": {
            "1": {
              "name": "punctuation.curlybrace.open.usp"
            }
          },
          "end": "(\\})",
          "endCaptures": {
            "1": {
              "name": "punctuation.curlybrace.close.usp"
            }
          },
          "name": "meta.callback.contents",
          "patterns": [
            {
              "include": "#statements"
            },
            {
              "include": "#variable-declaration"
            },
            {
              "include": "statement"
            },
            {
              "include": "#preprocessor"
            },
            {
              "include": "#comment"
            }
          ]
        }
      ]
    },
    "namespace-declaration": {
      "begin": "(?ix)\n  (?=\\bnamespace\\b) #start pattern at the beginning of the word structure without grabbing any characters",
      "end": "(?ix)\n  (?<=\\})   #stop pattern after the closing curly brace without grabbing any characters",
      "patterns": [
        {
          "begin": "(?ix)\n  \\b(namespace)\\b\\s+\n  ([_[:alpha:]][\\#\\$\\_[:alnum:]]*)",
          "beginCaptures": {
            "1": {
              "name": "keyword.declaration.namespace.usp"
            },
            "2": {
              "name": "entity.name.type.namespace.usp"
            }
          },
          "end": "(?ix)\n  (?=\\{) #stop pattern before the opening curly brace without grabbing any characters",
          "name": "meta.declaration.namespace.usp",
          "patterns": [
            {
              "include": "#comment"
            }
          ]
        },
        {
          "begin": "(\\{)",
          "beginCaptures": {
            "1": {
              "name": "punctuation.curlybrace.open.usp"
            }
          },
          "end": "(\\})(?!;)",
          "endCaptures": {
            "1": {
              "name": "punctuation.curlybrace.close.usp"
            }
          },
          "name": "meta.namespace.contents",
          "patterns": [
            {
              "include": "#class-declaration"
            },
            {
              "include": "#comment"
            }
          ]
        }
      ]
    },
    "class-declaration": {
      "begin": "(?ix)\n  (?=\n    (\\bstatic\\b\\s+)?\n    \\bclass\\b\n  ) #start pattern at the beginning of the word (static)? class  without grabbing any characters",
      "end": "(?ix)\n  (?<=};)   #stop pattern after the closing curly brace semicolon pair without grabbing any characters",
      "patterns": [
        {
          "begin": "(?ix)\n  (?:\\b(static)\\b\\s+)?               #possibly grab static\n  \\b(class)\\b\\s+                    #grab the word structure\n  ([_[:alpha:]][\\#\\$\\_[:alnum:]]*)  #grab the structure name",
          "beginCaptures": {
            "1": {
              "name": "keyword.modifier.class.usp"
            },
            "2": {
              "name": "keyword.declaration.class.usp"
            },
            "3": {
              "name": "entity.name.type.class.usp"
            }
          },
          "end": "(?ix)\n  (?=\\{) #stop pattern before the opening curly brace or before semicolon without grabbing any characters",
          "patterns": [
            {
              "include": "#comment"
            }
          ],
          "name": "meta.declaration.class.usp"
        },
        {
          "begin": "(\\{)",
          "beginCaptures": {
            "1": {
              "name": "punctuation.curlybrace.open.usp"
            }
          },
          "end": "(\\})(;)",
          "endCaptures": {
            "1": {
              "name": "punctuation.curlybrace.close.usp"
            },
            "2": {
              "name": "punctuation.terminator.class.usp"
            }
          },
          "name": "meta.class.contents",
          "patterns": [
            {
              "include": "#class-delegate-declaration"
            },
            {
              "include": "#class-eventhandler-declaration"
            },
            {
              "include": "#class-function-declaration"
            },
            {
              "include": "#variable-declaration"
            },
            {
              "include": "#comment"
            }
          ]
        }
      ]
    },
    "class-delegate-declaration": {
      "name": "meta.declaration.class.delegate.usp",
      "begin": "(?ix)\n  (?=\n    (\\bstatic\\b\\s+)?\n    \\bdelegate\\bs*\n  ) #start pattern at the beginning of the delegate keyword without grabbing any characters",
      "end": "(?ix)\n  (?<=\\;)   #stop pattern before semicolon without grabbing any characters",
      "patterns": [
        {
          "begin": "(?ix)\n  (?:\\b(static)\\b\\s+)?              #possibly grab static\n  \\b(delegate)\\b\\s+                 #grab the word delegate\n  \\b(function|integer_function|string_function|long_integer_function|signed_integer_function|signed_long_integer_function|SIMPLSHARPSTRING_FUNCTION)\\b\\s+ #grab delegate type\n  ([_[:alpha:]][\\#\\$\\_[:alnum:]]*)   #grab the delegate name",
          "beginCaptures": {
            "1": {
              "name": "keyword.modifier.delegate.usp"
            },
            "2": {
              "name": "keyword.declaration.delegate.usp"
            },
            "3": {
              "name": "keyword.declaration.function.usp"
            },
            "4": {
              "name": "entity.name.variable.delegate.usp"
            }
          },
          "end": "(;)",
          "endCaptures": {
            "1": {
              "name": "punctuation.terminator.delegate.usp"
            }
          },
          "patterns": [
            {
              "include": "#comment"
            },
            {
              "include": "#parenthesized-parameter-list"
            }
          ]
        }
      ]
    },
    "class-eventhandler-declaration": {
      "name": "meta.declaration.class.eventhandler.usp",
      "begin": "(?ix)\n  (?=\n    \\beventhandler\\b\n  ) #start pattern at the beginning of the eventhandler keyword without grabbing any characters",
      "end": "(?ix)\n  (?<=\\;)   #stop pattern after semicolon without grabbing any characters",
      "patterns": [
        {
          "begin": "(?ix)\n  \\b(eventhandler)\\b\\s+              #grab the word eventhandler\n  ([_[:alpha:]][\\#\\$\\_[:alnum:]]*)   #grab the delegate name",
          "beginCaptures": {
            "1": {
              "name": "keyword.modifier.eventhandler.usp"
            },
            "2": {
              "name": "entity.name.variable.eventhandler.usp"
            }
          },
          "end": "(;)",
          "endCaptures": {
            "1": {
              "name": "punctuation.terminator.eventhandler.usp"
            }
          },
          "patterns": [
            {
              "include": "#comment"
            },
            {
              "include": "#parenthesized-parameter-list"
            }
          ]
        }
      ]
    },
    "class-function-declaration": {
      "name": "meta.declaration.class.function.usp",
      "begin": "(?ix)\n  (?=(?:function|integer_function|string_function|long_integer_function|signed_integer_function|signed_long_integer_function|SIMPLSHARPSTRING_FUNCTION)) #start pattern at the beginning of the function keyword without grabbing any characters",
      "end": "(?ix)\n  (?<=;)   #stop pattern after the closing curly brace or before semicolon without grabbing any characters",
      "patterns": [
        {
          "begin": "(?ix)\n  (function|integer_function|string_function|long_integer_function|signed_integer_function|signed_long_integer_function|SIMPLSHARPSTRING_FUNCTION)\\b\\s+\n  ([_[:alpha:]][\\#\\$\\_[:alnum:]]*)",
          "beginCaptures": {
            "1": {
              "name": "keyword.declaration.function.usp"
            },
            "2": {
              "name": "entity.name.variable.function.usp"
            }
          },
          "end": "(;)",
          "endCaptures": {
            "1": {
              "name": "punctuation.terminator.function.usp patterns"
            }
          },
          "patterns": [
            {
              "include": "#preprocessor"
            },
            {
              "include": "#comment"
            },
            {
              "include": "#parenthesized-parameter-list"
            }
          ]
        }
      ]
    },
    "structure-members": {
      "patterns": [
        {
          "include": "#variable-declaration"
        }
      ]
    },
    "parenthesized-parameter-list": {
      "name": "meta.parameters",
      "begin": "(\\()",
      "beginCaptures": {
        "0": {
          "name": "punctuation.parenthesis.open.usp"
        }
      },
      "end": "(\\))",
      "endCaptures": {
        "0": {
          "name": "punctuation.parenthesis.close.usp"
        }
      },
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "include": "#parameter"
        },
        {
          "include": "#punctuation-comma"
        }
      ]
    },
    "parameter": {
      "begin": "(?ix)\n    \\s*(ByVal|ByRef|ReadOnlyByRef)?\\s*  #Possibly grab modifier\n    (?:\n      (integer|string|long_integer|signed_integer|signed_long_integer|SIMPLSHARPSTRING|eventargs)| #grab the variable type or\n      ([_[:alpha:]][\\#\\$\\_[:alnum:]]*) #grab the type\n    )",
      "beginCaptures": {
        "1": {
          "name": "keyword.modifier.parameter.usp"
        },
        "2": {
          "name": "keyword.declaration.parameter.usp"
        },
        "3": {
          "name": "entity.name.type.usp"
        }
      },
      "end": "(?ix)\n  (?=[\\,\\)])  #stop pattern before theres a comma or closing parenthesis without grabbing any characters",
      "patterns": [
        {
          "match": "([\\_[:alpha:]][\\_\\#\\_\\$[:alnum:]]*)",
          "name": "entity.name.variable.usp"
        },
        {
          "include": "#type-array-suffix"
        }
      ]
    },
    "type-array-suffix": {
      "begin": "\\[",
      "beginCaptures": {
        "0": {
          "name": "punctuation.squarebracket.open.usp"
        }
      },
      "end": "\\]",
      "endCaptures": {
        "0": {
          "name": "punctuation.squarebracket.close.usp"
        }
      },
      "patterns": [
        {
          "include": "#numeric-literal"
        },
        {
          "include": "#punctuation-comma"
        }
      ]
    },
    "preprocessor": {
      "patterns": [
        {
          "include": "#preprocessor-parameter-properties"
        },
        {
          "include": "#preprocessor-block-help"
        },
        {
          "include": "#preprocessor-single-line"
        }
      ]
    },
    "preprocessor-single-line": {
      "name": "meta.preprocessor.usp",
      "begin": "^\\s*(\\#)",
      "beginCaptures": {
        "1": {
          "name": "punctuation.separator.hash.usp"
        }
      },
      "end": "(?<=$)",
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "include": "#preprocessor-define-constant"
        },
        {
          "include": "#preprocessor-if-ifnot-defined"
        },
        {
          "include": "#preprocessor-endif"
        },
        {
          "include": "#preprocessor-category"
        },
        {
          "include": "#preprocessor-library"
        },
        {
          "include": "#preprocessor-include-path"
        },
        {
          "include": "#preprocessor-symbol-name"
        },
        {
          "include": "#preprocessor-hint"
        },
        {
          "include": "#preprocessor-help"
        },
        {
          "include": "#preprocessor-default-nonvolatile-volatile"
        },
        {
          "include": "#preprocessor-analog-digital-expand"
        },
        {
          "include": "#preprocessor-output-shift"
        },
        {
          "include": "#preprocessor-max-internal-buffer-size"
        },
        {
          "include": "#preprocessor-single"
        }
      ]
    },
    "preprocessor-define-constant": {
      "begin": "(?ix)\\G\n  \\b(define_constant)\\b\\s*  #Directive\n  \\b([_[:alpha:]][\\#\\$\\_[:alnum:]]*)\\b\\s* #Constant Name",
      "end": "(?=$)",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.defineconstant.usp"
        },
        "2": {
          "name": "entity.name.variable.preprocessor.symbol.usp"
        }
      },
      "patterns": [
        {
          "match": "(\\G0[xX])([[:xdigit:]]{1,4})",
          "captures": {
            "1": {
              "name": "constant.numeric.other.prefix.hex.usp"
            },
            "2": {
              "name": "constant.numeric.hex.usp"
            }
          }
        },
        {
          "match": "(\\G[0-9]+)",
          "name": "constant.numeric.decimal.usp"
        },
        {
          "match": "(\\G\\'.\\')",
          "name": "constant.character.usp"
        },
        {
          "match": "(\\G\\\".*?\\\")",
          "name": "string.quoted.double.usp"
        }
      ]
    },
    "preprocessor-if-ifnot-defined": {
      "begin": "(?ix)\\G\n  \\b(if_defined)|(if_not_defined)\\b #Directive",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.ifdefined.usp"
        },
        "2": {
          "name": "keyword.preprocessor.ifnotdefined.usp"
        }
      },
      "end": "(?=$)",
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "match": "\\b([_[:alpha:]][\\#\\$\\_[:alnum:]]*)\\b",
          "name": "entity.name.variable.preprocessor.symbol.usp"
        }
      ]
    },
    "preprocessor-endif": {
      "match": "(?ix)\\G\n  \\b(endif)\\b #Directive",
      "captures": {
        "1": {
          "name": "keyword.preprocessor.endif.usp"
        }
      }
    },
    "preprocessor-category": {
      "begin": "(?ix)\\G\n  \\b(category)\\b\\s* #Directive",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.category.usp"
        }
      },
      "end": "(?=$)",
      "patterns": [
        {
          "match": "\\G\\\"[0-9]*?\\\"",
          "name": "constant.numeric.category.usp"
        }
      ]
    },
    "preprocessor-library": {
      "begin": "(?ix)\\G\n  \\b((?:(?:user_simplsharp|crestron_simplsharp|user|crestron)_)library)\\b\\s*",
      "beginCaptures": {
        "1": {
          "patterns": [
            {
              "match": "(?i)((?:user_simplsharp).*)",
              "name": "keyword.preprocessor.usersimplsharplibrary.usp"
            },
            {
              "match": "(?i)((?:crestron_simplsharp).*)",
              "name": "keyword.preprocessor.crestronsimplsharplibrary.usp"
            },
            {
              "match": "(?i)((?:user).*)",
              "name": "keyword.preprocessor.userlibrary.usp"
            },
            {
              "match": "(?i)((?:crestron).*)",
              "name": "keyword.preprocessor.crestronlibrary.usp"
            }
          ]
        }
      },
      "end": "(?=$)",
      "patterns": [
        {
          "match": "\\G(\\\".*?\\\")",
          "name": "string.quoted.double.usp"
        }
      ]
    },
    "preprocessor-include-path": {
      "begin": "(?ix)\\G\n  \\b(includepath)\\b\\s* #Directive",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.includepath.usp"
        }
      },
      "end": "(?=$)",
      "patterns": [
        {
          "match": "\\G(\\\".*?\\\")",
          "name": "string.quoted.double.usp"
        }
      ]
    },
    "preprocessor-symbol-name": {
      "begin": "(?ix)\\G\n  \\b(symbol_name)\\b\\s* #Directive",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.symbolname.usp"
        }
      },
      "end": "(?=$)",
      "patterns": [
        {
          "match": "\\G(\\\".*?\\\")",
          "name": "string.quoted.double.usp"
        }
      ]
    },
    "preprocessor-hint": {
      "begin": "(?ix)\\G\n  \\b(hint)\\b\\s* #Directive",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.hint.usp"
        }
      },
      "end": "(?=$)",
      "patterns": [
        {
          "match": "\\G(\\\".*?\\\")",
          "name": "string.quoted.double.usp"
        }
      ]
    },
    "preprocessor-help": {
      "begin": "(?ix)\\G\n  \\b(help)\\b\\s* #Directive",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.help.usp"
        }
      },
      "end": "(?=$)",
      "patterns": [
        {
          "match": "\\G(\\\".*?\\\")",
          "name": "string.quoted.double.usp"
        }
      ]
    },
    "preprocessor-default-nonvolatile-volatile": {
      "match": "(?ix)\\G\n  \\b(default_nonvolatile)|(default_volatile)\\b #Directive",
      "captures": {
        "1": {
          "name": "keyword.preprocessor.defaultnonvolatile.usp"
        },
        "2": {
          "name": "keyword.preprocessor.defaultvolatile.usp"
        }
      }
    },
    "preprocessor-analog-digital-expand": {
      "begin": "(?ix)\\G\n  \\b(?:(analog_serial_expand)|(digital_expand))\\b\\s* #Directive",
      "end": "(?=$)",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.analogserialexpand.usp"
        },
        "2": {
          "name": "keyword.preprocessor.digitalexpand.usp"
        }
      },
      "patterns": [
        {
          "match": "(?ix)\\G\n  ([a-z]+)$",
          "name": "keyword.control.option.usp"
        }
      ]
    },
    "preprocessor-output-shift": {
      "begin": "(?ix)\\G\n  \\b(output_shift)\\b\\s* #Directive",
      "end": "(?=$)",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.outputshift.usp"
        }
      },
      "patterns": [
        {
          "match": "\\G[0-9]+",
          "name": "constant.numeric.decimal.usp"
        }
      ]
    },
    "preprocessor-max-internal-buffer-size": {
      "begin": "(?ix)\\G\n  \\b(max_internal_buffer_size)\\b\\s* #Directive",
      "end": "(?=$)",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.outputshift.usp"
        }
      },
      "patterns": [
        {
          "match": "\\G[0-9]+",
          "name": "constant.numeric.decimal.usp"
        }
      ]
    },
    "preprocessor-single": {
      "begin": "(?ix)\\G\n  (?:\\b\n    (?:\n      (print_to_trace)|\n      (enable_dynamic)|\n      (enable_stack_checking)|\n      (large_stack)|\n      (enable_trace)|\n      (encoding_ascii)|\n      (encoding_inherit_from_parent)|\n      (encoding_inherit_from_program)|\n      (encoding_utf16)|\n      (default_nonvolatile)|\n      (default_volatile)|\n      (endif)|\n      (if_series2)|\n      (if_series3)|\n      (if_series4)\n    )\\b)\n    \\s* #Directive",
      "end": "(?=$)",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.printtotrace.usp"
        },
        "2": {
          "name": "keyword.preprocessor.enabledynamic.usp"
        },
        "3": {
          "name": "keyword.preprocessor.enablestackchecking.usp"
        },
        "4": {
          "name": "keyword.preprocessor.largestack.usp"
        },
        "5": {
          "name": "keyword.preprocessor.enabletrace.usp"
        },
        "6": {
          "name": "keyword.preprocessor.encodingascii.usp"
        },
        "7": {
          "name": "keyword.preprocessor.encodinginheritfromparent.usp"
        },
        "8": {
          "name": "keyword.preprocessor.encodinginheritfromprogram.usp"
        },
        "9": {
          "name": "keyword.preprocessor.encodingutf16.usp"
        },
        "10": {
          "name": "keyword.preprocessor.defaultnonvolatile.usp"
        },
        "11": {
          "name": "keyword.preprocessor.defaultvolatile.usp"
        },
        "12": {
          "name": "keyword.preprocessor.endif.usp"
        },
        "13": {
          "name": "keyword.preprocessor.ifseries2.usp"
        },
        "14": {
          "name": "keyword.preprocessor.ifseries3.usp"
        },
        "15": {
          "name": "keyword.preprocessor.ifseries4.usp"
        }
      }
    },
    "preprocessor-parameter-properties": {
      "name": "meta.preprocessor.properties.usp",
      "begin": "(?ix)\n  (\\#)(begin_parameter_properties)\n  (\n    [\\_\\#\\_\\$\\,[:alnum:]\\s]*\n  )? #Parameter Properties Directive",
      "beginCaptures": {
        "0": {
          "name": "meta.preprocessor.usp"
        },
        "1": {
          "name": "punctuation.separator.hash.usp"
        },
        "2": {
          "name": "keyword.preprocessor.beginparameterproperties.usp"
        },
        "3": {
          "patterns": [
            {
              "match": "([\\_[:alpha:]][\\_\\#\\_\\$[:alnum:]]*)",
              "name": "entity.name.type"
            },
            {
              "include": "#punctuation-comma"
            }
          ]
        }
      },
      "end": "(?ix)\n  (\\#)(END_PARAMETER_PROPERTIES)",
      "endCaptures": {
        "0": {
          "name": "meta.preprocessor.usp"
        },
        "1": {
          "name": "punctuation.separator.hash.usp"
        },
        "2": {
          "name": "keyword.preprocessor.endparameterproperties.usp"
        }
      },
      "patterns": [
        {
          "include": "#preprocessor-parameter-properties-valid-unit"
        },
        {
          "include": "#preprocessor-parameter-properties-default-unit"
        },
        {
          "include": "#preprocessor-parameter-properties-default-value"
        },
        {
          "include": "#preprocessor-parameter-properties-list"
        },
        {
          "include": "#preprocessor-parameter-properties-bounds"
        },
        {
          "include": "#preprocessor-parameter-properties-short-description"
        },
        {
          "include": "#preprocessor-properties-block-description-notes"
        },
        {
          "include": "#comment"
        }
      ]
    },
    "preprocessor-parameter-properties-valid-unit": {
      "begin": "(?ix)\n  (\\#)\\b(propValidUnits)\\b #directive",
      "beginCaptures": {
        "0": {
          "name": "meta.preprocessor.usp"
        },
        "1": {
          "name": "punctuation.separator.hash.usp"
        },
        "2": {
          "name": "keyword.preprocessor.propvalidunits.usp"
        }
      },
      "end": "(;)",
      "endCaptures": {
        "1": {
          "name": "punctuation.terminator.parameteryproperty.usp"
        }
      },
      "patterns": [
        {
          "include": "#punctuation-assignment"
        },
        {
          "include": "#punctuation-pipe"
        },
        {
          "include": "#preprocessor-parameter-units"
        }
      ]
    },
    "preprocessor-parameter-properties-default-unit": {
      "begin": "(?ix)\n  (\\#)\\b(propDefaultUnits)\\b #directive",
      "beginCaptures": {
        "0": {
          "name": "meta.preprocessor.usp"
        },
        "1": {
          "name": "punctuation.separator.hash.usp"
        },
        "2": {
          "name": "keyword.preprocessor.propdefaultunits.usp"
        }
      },
      "end": "(;)",
      "endCaptures": {
        "1": {
          "name": "punctuation.terminator.parameteryproperty.usp"
        }
      },
      "patterns": [
        {
          "include": "#punctuation-assignment"
        },
        {
          "include": "#preprocessor-parameter-units"
        }
      ]
    },
    "preprocessor-parameter-properties-default-value": {
      "begin": "(?ix)\n  (\\#)\\b(propDefaultValue)\\b #directive",
      "beginCaptures": {
        "0": {
          "name": "meta.preprocessor.usp"
        },
        "1": {
          "name": "punctuation.separator.hash.usp"
        },
        "2": {
          "name": "keyword.preprocessor.propdefaultunits.usp"
        }
      },
      "end": "(;)",
      "endCaptures": {
        "1": {
          "name": "punctuation.terminator.parameteryproperty.usp"
        }
      },
      "patterns": [
        {
          "include": "#literals"
        }
      ]
    },
    "preprocessor-parameter-properties-list": {
      "begin": "(?ix)\n  (\\#)\\b(propList)\\b #directive",
      "beginCaptures": {
        "0": {
          "name": "meta.preprocessor.usp"
        },
        "1": {
          "name": "punctuation.separator.hash.usp"
        },
        "2": {
          "name": "keyword.preprocessor.proplist.usp"
        }
      },
      "end": "(;)",
      "endCaptures": {
        "1": {
          "name": "punctuation.terminator.parameteryproperty.usp"
        }
      },
      "patterns": [
        {
          "include": "#preprocessor-property-list-pair"
        },
        {
          "include": "#punctuation-comma"
        }
      ]
    },
    "preprocessor-parameter-properties-bounds": {
      "begin": "(?ix)\n  (\\#)\\b(propBounds)\\b #directive",
      "beginCaptures": {
        "0": {
          "name": "meta.preprocessor.usp"
        },
        "1": {
          "name": "punctuation.separator.hash.usp"
        },
        "2": {
          "name": "keyword.preprocessor.propBounds.usp"
        }
      },
      "end": "(;)",
      "endCaptures": {
        "1": {
          "name": "punctuation.terminator.parameteryproperty.usp"
        }
      },
      "patterns": [
        {
          "include": "#numeric-literal"
        },
        {
          "include": "#punctuation-comma"
        }
      ]
    },
    "preprocessor-parameter-properties-short-description": {
      "begin": "(?ix)\n  (\\#)\\b(propShortDescription)\\b #directive",
      "beginCaptures": {
        "0": {
          "name": "meta.preprocessor.usp"
        },
        "1": {
          "name": "punctuation.separator.hash.usp"
        },
        "2": {
          "name": "keyword.preprocessor.propShortDescription.usp"
        }
      },
      "end": "(;)",
      "endCaptures": {
        "1": {
          "name": "punctuation.terminator.parameteryproperty.usp"
        }
      },
      "patterns": [
        {
          "include": "#string-literal"
        }
      ]
    },
    "preprocessor-block-help": {
      "name": "meta.preprocessor.properties.help.usp",
      "contentName": "comment.block.documentation.usp",
      "begin": "(?i)(\\#)(help_begin)",
      "beginCaptures": {
        "1": {
          "name": "punctuation.separator.hash.usp"
        },
        "2": {
          "name": "keyword.preprocessor.helpbegin.usp"
        }
      },
      "end": "(?i)(\\#)(help_end)",
      "endCaptures": {
        "1": {
          "name": "punctuation.separator.hash.usp"
        },
        "2": {
          "name": "keyword.preprocessor.helpend.usp"
        }
      },
      "patterns": [
        {
          "include": "#comment"
        }
      ]
    },
    "preprocessor-properties-block-description-notes": {
      "name": "meta.preprocessor.properties.description.usp",
      "contentName": "comment.block.documentation.usp",
      "begin": "(?i)(\\#)(?:(begin_prop_full_description)|(begin_prop_notes))",
      "beginCaptures": {
        "0": {
          "name": "meta.preprocessor.usp"
        },
        "1": {
          "name": "punctuation.separator.hash.usp"
        },
        "2": {
          "name": "keyword.preprocessor.beginpropfulldescription.usp"
        },
        "3": {
          "name": "keyword.preprocessor.beginpropnotes.usp"
        }
      },
      "end": "(?i)(\\#)(?:(end_prop_full_description)|(end_prop_notes))$",
      "endCaptures": {
        "0": {
          "name": "meta.preprocessor.usp"
        },
        "1": {
          "name": "punctuation.separator.hash.usp"
        },
        "2": {
          "name": "keyword.preprocessor.endpropfulldescription.usp"
        },
        "3": {
          "name": "keyword.preprocessor.endpropnotes.usp"
        }
      }
    },
    "preprocessor-parameter-units": {
      "patterns": [
        {
          "match": "(?ix)\n  \\b(unitString|unitDecimal|unitHex|unitPercent|unitCharacter|unitTime|unitTicks)\\b #directive",
          "name": "keyword.preprocessor.$1."
        }
      ]
    },
    "preprocessor-property-list-pair": {
      "patterns": [
        {
          "match": "(\\{)([^}]*)(\\})",
          "captures": {
            "1": {
              "name": "punctuation.curlybrace.open.usp"
            },
            "2": {
              "patterns": [
                {
                  "match": "(.*)\\s?(,)\\s?(.*)",
                  "captures": {
                    "1": {
                      "patterns": [
                        {
                          "include": "#literals"
                        }
                      ]
                    },
                    "2": {
                      "name": "punctuation.comma.usp"
                    },
                    "3": {
                      "patterns": [
                        {
                          "include": "#string-literal"
                        }
                      ]
                    }
                  }
                }
              ]
            },
            "3": {
              "name": "punctuation.curlybrace.close.usp"
            }
          }
        }
      ]
    },
    "punctuation": {
      "patterns": [
        {
          "include": "#punctuation-arithmetic"
        },
        {
          "include": "#punctuation-bitwise"
        },
        {
          "include": "#punctuation-comparison-unequal"
        },
        {
          "include": "#punctuation-relational"
        },
        {
          "include": "#punctuation-equal"
        },
        {
          "include": "#punctuation-grouping"
        },
        {
          "include": "#punctuation-structure"
        }
      ]
    },
    "punctuation-arithmetic": {
      "match": "(?i)\\+|-(?!>)|\\*|\\/|S\\/|%|mod|umod",
      "name": "keyword.operator.arithmetic.usp"
    },
    "punctuation-bitwise": {
      "patterns": [
        {
          "name": "keyword.operator.bitwise.shift.usp",
          "match": "(?i)<<|>>"
        },
        {
          "name": "keyword.operator.bitwise.rotate.usp",
          "match": "{{|}}"
        },
        {
          "name": "keyword.operator.bitwise.usp",
          "match": "(?i)\\&|not|\\^|\\|"
        },
        {
          "name": "keyword.operator.bitwise.usp",
          "match": "\\!|&&|\\|\\|"
        }
      ]
    },
    "punctuation-comparison-unequal": {
      "patterns": [
        {
          "name": "keyword.operator.comparison.usp",
          "match": "(<>)"
        }
      ]
    },
    "punctuation-relational": {
      "patterns": [
        {
          "name": "keyword.operator.relational.usp",
          "match": "<=|>=|<|>|S<=|S>=|S<|S>"
        }
      ]
    },
    "punctuation-equal": {
      "begin": "[^=]+(=)",
      "beginCaptures": {
        "1": {
          "name": "keyword.operator.assignment.usp"
        }
      },
      "end": "(;)",
      "endCaptures": {
        "1": {
          "name": "punctuation.terminator.statement.usp"
        }
      },
      "patterns": [
        {
          "match": "(=)",
          "name": "keyword.operator.comparison.usp"
        }
      ]
    },
    "punctuation-assignment": {
      "patterns": [
        {
          "match": "=",
          "name": "keyword.operator.assignment.usp"
        }
      ]
    },
    "punctuation-grouping": {
      "patterns": [
        {
          "include": "#punctuation-square-bracket"
        },
        {
          "include": "punctuation-parenthesis"
        },
        {
          "include": "punctuation-curlybrace"
        }
      ]
    },
    "punctuation-structure": {
      "patterns": [
        {
          "include": "#punctuation-comma"
        },
        {
          "include": "#punctuation-semicolon"
        },
        {
          "include": "#punctuation-parenthesis"
        },
        {
          "include": "#punctuation-accessor"
        },
        {
          "include": "#punctuation-dot"
        },
        {
          "include": "#punctuation-pipe"
        }
      ]
    },
    "punctuation-square-bracket": {
      "begin": "\\[",
      "beginCaptures": {
        "0": {
          "name": "punctuation.squarebracket.open.usp"
        }
      },
      "end": "\\]",
      "endCaptures": {
        "0": {
          "name": "punctuation.squarebracket.close.usp"
        }
      },
      "patterns": [
        {
          "include": "#intrusive"
        },
        {
          "include": "#punctuation-comma"
        }
      ]
    },
    "punctuation-curlybrace": {
      "begin": "\\{",
      "beginCaptures": {
        "0": {
          "name": "punctuation.curlybrace.open.usp"
        }
      },
      "end": "\\}",
      "endCaptures": {
        "0": {
          "name": "punctuation.curlybrace.close.usp"
        }
      },
      "patterns": [
        {
          "include": "#intrusive"
        },
        {
          "include": "#punctuation-comma"
        }
      ]
    },
    "punctuation-parenthesis": {
      "begin": "(\\()",
      "beginCaptures": {
        "0": {
          "name": "punctuation.parenthesis.open.usp"
        }
      },
      "end": "(\\))",
      "endCaptures": {
        "0": {
          "name": "punctuation.parenthesis.close.usp"
        }
      },
      "patterns": [
        {
          "include": "#expression"
        }
      ]
    },
    "punctuation-comma": {
      "match": "\\,",
      "name": "punctuation.comma.usp"
    },
    "punctuation-semicolon": {
      "match": "\\;",
      "name": "punctuation.terminator.usp"
    },
    "punctuation-dot": {
      "match": "(\\.)",
      "name": "punctuation.structure.dot.usp"
    },
    "punctuation-pipe": {
      "match": "(\\|)",
      "name": "punctuation.structure.pipe.usp"
    },
    "comment": {
      "patterns": [
        {
          "include": "#comment-single-line"
        },
        {
          "include": "#comment-block"
        }
      ]
    },
    "comment-single-line": {
      "name": "comment.line.double-slash.usp",
      "begin": "(^\\s+)?(\\/\\/).*$",
      "while": "^(\\s*)(\\/\\/).*$",
      "captures": {
        "1": {
          "name": "punctuation.whitespace.comment.leading.usp"
        },
        "2": {
          "name": "punctuation.definition.comment.usp"
        }
      }
    },
    "comment-block": {
      "name": "comment.block.usp",
      "begin": "\\/\\*",
      "end": "\\*\\/",
      "captures": {
        "0": {
          "name": "punctuation.definition.comment.usp"
        }
      }
    },
    "bracketed-argument-list": {
      "begin": "\\[",
      "beginCaptures": {
        "0": {
          "name": "punctuation.squarebracket.open.usp"
        }
      },
      "end": "\\]",
      "endCaptures": {
        "0": {
          "name": "punctuation.squarebracket.close.usp"
        }
      },
      "patterns": [
        {
          "include": "#argument"
        },
        {
          "include": "#punctuation-comma"
        }
      ]
    },
    "argument-list": {
      "begin": "\\(",
      "beginCaptures": {
        "0": {
          "name": "punctuation.parenthesis.open.usp"
        }
      },
      "end": "\\)",
      "endCaptures": {
        "0": {
          "name": "punctuation.parenthesis.close.usp"
        }
      },
      "patterns": [
        {
          "include": "#argument"
        },
        {
          "include": "#punctuation-comma"
        }
      ]
    },
    "argument": {
      "patterns": [
        {
          "name": "storage.modifier.$1.usp",
          "match": "(?i)\\b(ByRef|ByVal|ReadOnlyByRef)\\\\b\""
        },
        {
          "include": "#expression"
        }
      ]
    },
    "type": {
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "include": "#ref-modifier"
        },
        {
          "include": "#type-builtin"
        },
        {
          "include": "#type-name"
        }
      ]
    },
    "type-builtin": {
      "match": "(?ix)\\b(integer|long_integer|signed_integer|signed_long_integer|string|structure)\\b",
      "comment": "Crestron Built In Types",
      "name": "keyword.type.$1.usp"
    },
    "type-name": {
      "patterns": [
        {
          "match": "(?(@?[_[:alpha:]][\\_\\#\\_\\$[:alnum:]]*)\\s*(\\.))",
          "captures": {
            "1": {
              "name": "entity.name.type.usp"
            },
            "2": {
              "name": "punctuation.accessor.usp"
            }
          }
        },
        {
          "match": "(?:(\\.)\\s*(@?[_[:alpha:]][\\_\\#\\_\\$_[:alnum:]]*))",
          "captures": {
            "1": {
              "name": "punctuation.accessor.usp"
            },
            "2": {
              "name": "entity.name.type.usp"
            }
          }
        },
        {
          "name": "entity.name.type.usp",
          "match": "(@?[_[:alpha:]][\\_\\#\\_\\$_[:alnum:]]*)"
        }
      ]
    },
    "designation-pattern": {
      "patterns": [
        {
          "include": "#intrusive"
        },
        {
          "begin": "\\(",
          "beginCaptures": {
            "0": {
              "name": "punctuation.parenthesis.open.usp"
            }
          },
          "end": "\\)",
          "endCaptures": {
            "0": {
              "name": "punctuation.parenthesis.close.usp"
            }
          },
          "patterns": [
            {
              "include": "#punctuation-comma"
            },
            {
              "include": "#designation-pattern"
            }
          ]
        },
        {
          "include": "#simple-designation-pattern"
        }
      ]
    },
    "simple-designation-pattern": {
      "patterns": [
        {
          "match": "(?x)\n(?:\n  ([_[:alpha:]][\\#\\$\\_[:alnum:]]*) #Name\n  (?:\\s*                   # array suffix?\n    (?:(\\[)\\d*(\\])\\s*)\n    (?:(\\[)\\d*(\\])\\s*)?\n  )?\n)",
          "captures": {
            "1": {
              "name": "entity.name.variable.local.usp"
            },
            "2": {
              "name": "punctuation.squarebracket.open.usp"
            },
            "3": {
              "name": "punctuation.squarebracket.close.usp"
            },
            "4": {
              "name": "punctuation.squarebracket.open.usp"
            },
            "5": {
              "name": "punctuation.squarebracket.close.usp"
            }
          }
        }
      ]
    }
  }
}